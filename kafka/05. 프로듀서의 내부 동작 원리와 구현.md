## 프로듀서의 내부 동작 원리와 구현

### 5.1 파티셔너 

- 카프카의 토픽은 병렬 처리가 가능하도록 하기 위해 파티션으로 나뉘고, 최소 하나 또는 둘 이상의 파티션으로 구성
- 프로듀서가 보낸 메시지는 해당 토픽 내 각 파티션의 '로그 세그먼트'에 저장
- 따라서, 프로듀서는 카프카로 메시지를 보낼 때 해당 토픽의 어느 파티션으로 메시지를 보내야 할지 결정이 필요하며, 이때 사용하는 것이 '파티셔너'
- 프로듀서가 파티션을 결정하는 알고리즘은 기본적으로 '메시지의 키를 해시(Hash)' 처리하여 파티션을 구하는 방식 사용
  - 메시지의 키값이 동일한 경우, 모두 같은 파티션으로 전송

- 많은 양의 메시지가 카프카로 인입되는 경우, 카프카는 클라이언트의 처리량을 높이기 위해 '토픽의 파티션을 늘릴 수 있는 기능 제공'
  - 파티션 수가 변경됨과 동시에 '메시지의 키와 매핑된 해시 테이블 변경'
  - 파티션 수가 변경된 이후에는 '동일한 메시지 키를 이용하여 메시지를 전송하더라도 다른 파티션으로 전송될 수 있음'

> 파티션 수 증가에 따른 해시 변경

![캡처](https://velog.velcdn.com/images/woorung/post/caa38de4-35a1-4c78-9e4a-8b43e7770ba0/image.png)

- 메시지의 키를 이용해 카프카로 메시지를 전송하는 경우, 관리자의 의도와는 다른 방식으로 메시지 전송이 이뤄질 수 있으므로 되도록 파티션 수 변경을 하지 않는 것을 권장

#### 5.1.1 라운드 로빈 전략

- 프로듀서의 메시지 중 레코드(메시지)의 key 값은 필수값이 아님
  - 따라서, 레코드 key 값을 지정하지 않고 메시지 전송 가능
  - key 값 미지정 
    - key 값 : null
    - 기본 (Default) 알고리즘 : 라운드 로빈

- 파티셔너를 거친 후 레코드들은 배치 처리를 위해 프로듀서의 '버퍼 메모리 영역에서 잠시 대기 후 카프카로 전송'
  - 배치 처리를 위해 잠시 메시지들이 대기하는 과정에서 라운드 로빈 전략은 비효율

> 비효율적인 라운드 로빈 전략 예시

![캡처](https://velog.velcdn.com/images/woorung/post/79d7f6a7-05e6-4174-923c-5881e3ecf13d/image.png)

- 토픽 : 1 (A) 
- 파티션 수 : 3
- 각 파티션별로 배치 전송을 위해 필요한 레코드 수 : 3 
   

- 토픽 A - 파티션 2 는 배치와 압축의 효과를 얻지 못한 채 레코드 하나만 카프카로 전송되므로 비효율
  - 프로듀서 옵션 설정을 통해 '특정 시간 초과 시 즉시 카프카로 레코드들을 전송'하도록 설정 가능
   

- 카프카에서는 이러한 비효율적 전송 방식을 보완하기 위해 '스티키 파티셔닝 (Sticky Partitioning) 전략 도입

#### 5.1.2 스티키 파티셔닝 전략

- \* 하나의 파티션에 레코드 수를 먼저 채워서 카프카로 빠르게 배치 전송하는 전략
- 라운드 로빈 전략에서 지연 시간이 불필요하게 증가되는 비효율적인 전송 방식을 개선하고자 카프카 2.4 버전부터 도입
  
![캡처](https://velog.velcdn.com/images/woorung/post/71a5ddb7-bf9d-4c9d-8378-0051f14e3b3b/image.png)

- 토픽 : 1 (A)
- 파티션 수 : 3
- 각 파티션별로 배치 전송을 위해 필요한 레코드 수 : 3 
   

- 배치를 위한 레코드 수에 도달할 때까지 파티셔너는 다른 파티션으로 보내지 않고, 동일한 파티션으로 레코드 저장
  - '토픽A - 파티션0' 에는 레코드 1~3 까지 채워졌기 때문에 배치를 위한 최소 레코드 수를 충족했으므로 즉시 카프카로 배치 전송 수행 가능

- 라운드 로빈 전략에서는 레코드 5개를 처리했음에도 카프카로 전송하지 못했지만, 스티키 파티셔닝 전략에서는 배치 전송 가능
  - \* 라운드 로빈 전략 보다 효율적
  - \* 메시지 순서가 중요하지 않은 경우 스티키 파티셔닝 전략 적용 권장
  - 스티키 파티셔닝 전략 적용을 통해 약 30% 이상 지연 시간 감소 및 프로듀서의 CPU 사용률 절감 효과

![캡처](https://velog.velcdn.com/images/woorung/post/e671b771-1d68-4aa3-884f-a3949bea628a/image.png)
![캡처](https://velog.velcdn.com/images/woorung/post/227cc813-e978-4079-a6ad-b6e3bbab7d8b/image.png)

### 5.2 프로듀서의 배치 

- 프로듀서에서는 카프카로 메시지를 전송하기 전, 배치 전송을 위해 토픽의 파티션별로 레코드들을 잠시 보관
- 프로듀서의 배치 전송 방식은 단건의 메시지를 전송하는 것이 아니라 한 번에 다량의 메시지를 묶어서 전송하는 방법


- 프로듀서 배치 전송 옵션 

> buffer.memory

- 카프카로 메시지들을 전송하기 위해 담아두는 프로듀서의 버퍼 메모리 옵션
- 기본값 : 32MB

> batch.size

- 배치 전송을 위해 메시지들을 묶는 단위를 설정하는 배치 크기 옵션
- 기본값 : 16KB

> linger.ms

- 배치 전송을 위해 버퍼 메모리에서 대기하는 메시지들의 최대 대기시간을 설정하는 옵션
- 단위 : ms 
- 기본값 : 0 
  - 기본값이 0인 경우, 배치 전송을 위해 기다리지 않고 메시지들이 즉시 전송


> 장점

- 불필요한 I/O를 줄일 수 있기 때문에 단건으로 메시지를 전송하는 방식 보다 효율적
- 카프카의 요청 수를 줄여주는 효과
  - 1,000개의 메시지를 단건으로 보낼 시 1,000번 요청 필요
  - 배치 전송 시 100개의 메시지를 10번 요청하여 처리 가능

> 카프카를 사용하는 목적에 따라 '처리량'을 높일지, '지연 없는 전송'을 해야 할지 선택 필요

- 높은 처리량이 필요한 경우, 효율적인 배치 전송을 위해 프로듀서 설정 변경 필요
  - batch.size, linger.ms 값을 크게 설정 필요
  - \* buffer.memory 설정 값이 batch.size 보다 커야함 
- 지연 없는 전송이 필요한 경우, 프로듀서의 배치 전송 관련 설정 제거 필요
  - batch.size, linger.ms 값을 작게 설정 필요

### 5.3 중복 없는 전송 

- 카프카는 사용자들의 개발 편의를 높이기 위해 중복 없이 메시지를 전송할 수 있는 기능 제공
   

- 메시지 시스템들의 메시지 전송 방식

> 적어도 한 번 전송 방식 (at-least-once)

- 카프카의 기본 메시지 전송 방식

![캡처](https://postfiles.pstatic.net/MjAyMjEwMTBfMTcx/MDAxNjY1NDA4OTAzODgx.OsfUaWaGWZ71Uf35m3_B0VOHHzPRChWtWOLqRlAylE8g.hfpnd_6NTW9z8koKI1AUhrYK2_lBXXLma5tYoQu7mcUg.JPEG.wnsghi1/IMG_1277.jpg?type=w773)

1. 프로듀서가 브로커의 특정 토픽으로 메시지 A 전송
2. 브로커는 메시지 A 를 기록하고, ACK 를 프로듀서에게 응답
3. 브로커의 ACK 를 받은 프로듀서는 다음 메시지인 메시지 B 를 브로커에게 전송
4. 브로커는 메시지 B 를 기록하고, ACK 를 프로듀서에게 전송하려 하는 시점에 네트워크 오류 또는 브로커 장애가 발생하여 ACK 응답 실패
5. 메시지 B 를 전송한 후 브로커로부터 ACK 를 받지 못한 프로듀서는 브로커가 메시지 B 를 받지 못했다고 판단하여 메시지 B 재전송
   - **\* 해당 시점에서 프로듀서는 브로커가 메시지를 저장하고 ACK 만 응답하지 못한 것인지, 메시지를 저장하지 못해서 ACK 를 응답하지 못한 것인지 판단 불가** 
   - 하지만, '적어도 한 번 전송' 방식에 의하여 메시지 B 를 재전송하여 '최소한 하나의 메시지에 대하여 보장'
     - 브로커가 메시지 B 를 받지 못한 상황이라면, 브로커는 메시지 B 저장
     - 브로커가 메시지 B 를 저장하고, ACK 만 전송하지 못한 상황이라면, 메시지 B 는 중복 저장

> 최대 한 번 전송 (at-most-once)

![캡처](https://postfiles.pstatic.net/MjAyMjEwMTBfNjgg/MDAxNjY1NDA5MzI5MzI4.VSF38txaqqfj1KlKbDJ6vwxI-frVR-DTqodsRQiuOwog.J4cN6GJT-PY0TiQj39BwsDZj9TrvQLsFFdYtFdGPUYcg.JPEG.wnsghi1/IMG_1278.jpg?type=w773)

1. 프로듀서가 브로커의 특정 토픽으로 메시지 A 전송
2. 브로커는 메시지 A 저장 후 ACK 를 프로듀서에게 응답
3. 프로듀서는 다음 메시지인 메시지 B 를 브로커에게 전송
4. 브로커는 메시지 B 를 저장하지 못하고, ACK 응답 실패
5. 프로듀서는 브로커가 메시지 B 를 받았다고 가정하고, 다음 메시지인 메시지 C 전송

- **\* 최대 한 번 전송은 프로듀서가 ACK 를 받지 못하더라도 메시지 중복 가능성을 회피하기 위해 재전송 하지 않음**
  - 대량 로그 수집, IoT 환경에서 사용

> 정확히 한 번 전송 (exactly-once) 

![캡처](https://postfiles.pstatic.net/MjAyMjEwMTBfMjQ1/MDAxNjY1NDA5NjE0MzIx.K-Y2vILwluvG0j6pqP856zzA97G2pa0yPoH1KlaTh6wg.oPvvJj2VtyfK6WPVQkHJ9FwIIY2qiMOe-osPwo0n3wMg.JPEG.wnsghi1/IMG_1279.jpg?type=w773)

1. 프로듀서가 브로커의 특정 토픽으로 메시지 A 전송 (PID - Produce ID 와 메시지 번호 0을 헤더에 포함)
2. 브로커는 메시지 A 를 저장하고, PID와 메시지 번호 0을 메모리에 기록한 뒤 ACK 를 프로듀서에게 응답
3. 프로듀서는 다음 메시지인 메시지 B 를 브로커에 전송 (PID 는 동일하고 0이며, 메시지 번호는 1이 증가하여 1)
4. 브로커는 메시지 B를 저장하고, PID와 메시지 번호 1을 메모리에 기록하지만, 네트워크 오류 또는 브로커 장애로 인하여 ACK 응답 실패
5. **\* 브로커로부터 ACK 를 받지 못한 프로듀서는 브로커가 메시지 B를 받지 못했다고 판단해 메시지 B를 재전송**

- **'적어도 한 번 전송' 방식과 유사하지만, 프로듀서가 재전송한 메시지 B의 헤더에서 PID(0)와 메시지 번호(1)를 비교해서 메시지 B가 이미 브로커에 저장되어 있는 것을 확인한 브로커는 메시지를 중복 저장하지 않고, ACK 만 응답**
  - 'PID' 와 '메시지 번호'를 사용하기 때문에 메시지 중복 발생 X
    - 'PID' 와 '메시지 번호' 는 snapshot 파일에 저장하여 관리
  - 프로듀서가 보낸 메시지 번호가 브로커가 갖고 있는 메시지 번호보다 정확하게 하나가 큰 경우가 아니라면, 브로커는 프로듀서의 메시지 저장 X

- **하지만, 중복을 피하기 위한 메시지 비교 동작에는 오버헤드 발생**
  - 메시지에 단순한 숫자 필드만 추가하는 방법으로 구현하였기 때문에 오버헤드가 높은 편은 아님

- 따라서, 중복 없는 메시지 전송 필요 시 해당 방식 적용 권장

> 중복 없는 전송을 위한 프로듀서 설정 

| 프로듀서 옵션                               | 값     | 설명                                                                                                              |  
|---------------------------------------|-------|-----------------------------------------------------------------------------------------------------------------| 
| enable.idempotence                    | true  | 프로듀서가 중복 없는 전송을 허용할지 결정하는 옵션, 기본값은 false 이며, true 로 사용할 경우, 나머지 옵션도 반드시 변경 필요 (나머지 옵션 미설정 시 ConfigException 발생) | 
| max.in.flight.requests.per.connection | 1 ~ 5 | ACK 를 받지 않은 상태에서 하나의 커넥션에서 보낼 수 있는 최대 요청 수 (기본값은 5이며, 5 이하로 설정 필요)                                              | 
| acks                                  | all   | 프로듀서 acks 와 관련된 옵션으로, 기본값은 1이며, all 로 설정 필요 |                                                                    |                                                                                                      |
| retries                               | 5     | ACK 를 받지 못한 경우, 재시도를 해야 하므로 0보다 큰 값으로 설정 필요 |



