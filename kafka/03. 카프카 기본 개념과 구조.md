## 3.1 카프카 기초 다지기 


### 카프카를 구성하는 주요 요소

> 주키퍼 (Zookeeper)

- 아파치 프로젝트 애플리케이션 이름
- 카프카 메타데이터 관리 및 브로커의 정상 상태 (Health Check) 점검 담당

> 카프카 (Kafka) / 카프카 클러스터 (Kafka cluster)

- 아파치 프로젝트 애플리케이션 이름
- 여러 대의 브로커를 구성한 클러스터 의미

> 브로커 (Broker)

- 카프카 애플리케이션이 설치된 서버 또는 노드

> 프로듀서 (Producer)

- 카프카로 메시지를 보내는 역할을 하는 클라이언트 총칭

> 컨슈머 (Consumer)

- 카프카에서 메시지를 꺼내가는 역할을 하는 클라이언트 총칭

> 토픽 (Topic)

- 카프카는 메시지 피드들을 토픽으로 구분
- 각 토픽의 이름은 카프카 내에서 고유

> 파티션 (Partition)

- 병렬 처리 및 고성능을 얻기 위해 하나의 토픽을 여러 개로 나눈 것

> 세그먼트 (Segment)

- 프로듀서가 전송한 실제 메시지가 브로커의 로컬 디스크에 저장되는 파일

> 메시지 (Message) / 레코드 (Record)

- 프로듀서가 브로커로 전송하거나, 컨슈머가 읽어가는 데이터 조각 의미

### 3.1.1 리플리케이션

- 각 메시지들을 여러 개로 복제하여 카프카 클러스터 (여러 대의 브로커) 내 브로커들에 분산시키는 동작 의미
    - 하나의 브로커가 종료되더라도 안전성 유지 가능

> replication-factor

- 카프카 내 리플리케이션 유지 개수
- --replication-factor 1
    - 리플리케이션 : 1개

- --replication-factor 3
    - 원본을 포함한 리플리케이션 : 3개

- replication-factor 수가 커지면, 안정성은 높아지지만, 브로커 리소스를 많이 사용하게 됨
    - 브로커가 3개인 경우, 운영 예시
        - 테스트 / 개발 환경 : replication-factor 1
        - 운영 환경 (로그성 메시지로서 약간의 유실 허용) : replication-factor 2
        - 운영 환경 (유실 미허용) : replication-factor 3

### 3.1.2 파티션

- 토픽 하나를 여러 개로 나눠 병렬 처리가 가능하도록 만든 것
- 파티션 수만큼 컨슈머 연결 가능
- 파티션 번호는 0부터 시작
- 파티션 수는 초기 생성 후 언제든 늘릴 수 있지만, 반대로 파티션 수는 줄일 수 없음
    - 따라서, 초기에 토픽 생성 시, 파티션 수를 작게 생성한 후 메시지 처리량, LAG 등을 모니터링을 통해 점진적으로 늘려가는 방법이 좋음
  > LAG : 프로듀서가 보낸 메시지 수 - 컨슈머가 가져간 메시지 수
    - 프로듀서가 보낸 총 메시지 수 : 5개
    - 컨슈머가 처리한 메시지 수 : 4개
    - LAG : 1개

### 3.1.3 세그먼트

- 프로듀서에 의해 브로커로 전송된 메시지는 토픽의 파티션에 저장
- 각 메시지들은 '세그먼트'라는 로그 파일의 형태로 브로커의 로컬 디스크에 저장
    - 토픽 이름-파티션 번호 포맷으로 저장

## 3.2 카프카의 핵심 개념

### 3.2.1 분산 시스템

- 분산 시스템은 네트워크상에 연결된 컴퓨터들의 그룹 의미
    - 단일 시스템이 갖지 못한 높은 성능 목표
- 장애 대응 탁월
    - 하나의 서버/노드에 장애가 발생하더라도 다른 서버 또는 노드가 처리 가능
    - 부하가 높은 경우, 시스템 확장 가능
- 카프카 또한 브로커를 추가하는 방식으로 확장 가능

### 3.2.2 페이지 캐시

- 카프카는 OS의 페이지 캐시를 활요하는 방식으로 설계
- 페이지 캐시는 디스크에 직접 읽고 쓰는 대신, 물리 메모리 중 애플리케이션이 사용하지 않는 일부 잔여 메모리 활용
    - 디스크 I/O 접근 최소화를 통한 성능 향상
    - 카프카 <=> 페이지 캐시 <=> 디스크

### 3.2.3 배치 전송 처리

- 카프카는 프로듀서, 컨슈머와 통신하며 수많은 메시지를 주고 받는데, 이때 발생하는 수많은 통신을 묶어서 처리 가능하다면, 단건으로 통신할 때에 비해 네트워크 오버헤드 최소화 가능

### 3.2.4 압축 전송

- 카프카는 gzip, snappy, lz4, zstd 등의 압축 타입 지원
- 압축만으로도 네트워크 대역폭이나 회선 비용 등을 줄일 수 있으며, 배치 전송과 결합해 사용한다면 높은 효과
    - 높은 압축률 : gzip, zstd
    - 빠른 응답 속도 : lz4, snappy

### 3.2.5 오프셋

![캡처](https://sookocheff.com/post/kafka/kafka-in-a-nutshell/log-anatomy.png)

- 오프셋 : 파티션의 메시지가 저장되는 위치
- 오프셋은 순차적으로 증가하는 숫자 형태
- 각 파티션에서의 오프셋은 고유한 숫자
- 카프카에서는 오프셋을 통해 메시지의 순서를 보장하고, 컨슈머에서는 마지막까지 읽은 위치를 알 수 있음

### 3.2.6 고가용성 보장

