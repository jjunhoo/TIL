## 아파치 카프카 개요

### 아파치 카프카
- 아파치 카프카는 여러 대의 분산 서버에서 대량의 데이터를 처리하는 분산 메시징 시스템이다.
- 메시지 (데이터)를 받고, 받은 메시지를 다른 시스템이나 장치에 보내기 위해 사용된다.
- 대량의 데이터를 '높은 처리량'과 '실시간'으로 취급
    - 확장성 : 여러 서버로 '확장 구성' 할 수 있기 때문에 데이터 양에 따라 시스템 확장이 가능
    - 영속성 : 수신한 데이터를 '디스크에 유지' 가능하기 때문에 언제라도 데이터 읽기 가능
    - 유연성 : '연계 가능 제품' 이 다양하기 때문에 제품이나 시스템을 연결하는 허브 역할을 한다.
    - 신뢰성 : '메시지 전달 보증'을 하므로 데이터 분실을 걱정하지 않아도 된다.
    
### 카프카 탄생 배경
#### 링크드인의 시스템 요구사항
- 카프카는 2011년 미국 링크드인에서 출발하였으며, 링크드인 웹사이트에서 생성되는 로그를 처리하여 웹사이트 활동을 추적하는 것을 목적으로 개발되었다. 
    
### 카프카 이전 제품
> 메시지 큐
- RabbitMQ, ActiveMQ, JMS, IBM MQ
1. 강력한 전달 보증이 오버 스펙이었다.
    - 하나의 메시지가 정확히 한 번만 전송되는 것을 보증할 수 있다.
2. 스케일 아웃이 용이한 제품이 아니었다.
    - 처리 성능을 높이는 목적으로 필요 시 노드를 추가할 수 있는 스케일 아웃 기능을 전제로 한 제품이 당시에는 없었다.
3. 메시지가 대량으로 쌓이는 것을 예상하지 않았다.
    - 카프카 등장 이전의 메시지 큐에서는 메시지를 쌓아둘 수 있었는데, 큐에 쌓인 메시지는 즉시 이용되는 것으로 예상하고 있었으며, 장시간에 걸쳐 대량으로 축적하는 것은 예상하지 않았다.
    
> 로그 수집 시스템
- 실시간으로 데이터를 수집한다는 관점에서 생각할 수 있는 것은 로그 수집을 위한 미들웨어이다.

1. HDFS로 데이터 축적과 배치 처리만 고려했다.
2. 알기 쉬운 API가 없다.
3. 수신하는 쪽이 임의로 메시지를 수신하기 어렵다.

> ETL 도구 
- 데이터 발생원에서 데이터를 추출하고 필요에 따라 변환해 데이터베이스와 데이터 웨어하우스에 로드하는 기능
- Extract - 추출, Transform - 변환, Load - 로드 
- DataStage, Interstage, Cosminexus, Informatica PowerCenter, Talend 등

1. 데이터를 파일 단위로 다룬다.
2. 수신하는쪽이 임의로 메시지를 수신하기 어렵다.

### 카프카로 링크드인 요구사항 실현하기
- 위 요구사항으로 인하여 2009년 당시 링크드인은 카프카 개발을 시작
- 요구사항
    1. 높은 처리량으로 실시간 처리한다.
    2. 임의의 타이밍에 데이터를 읽는다.
    3. 다양한 제품과 시스템에 쉽게 연동한다.
    4. 메시지를 잃지 않는다.
- 실현 수단
    1. 메시징 모델과 스케일 아웃형 아키텍처
    2. 디스크로의 데이터 영속화
    3. 이해하기 쉬운 API 제공
    4. 전달 보증
    
> 메시징 모델과 스케일 아웃
- Producer : 메시지 생산자
- Broker : 메시지 수집/전달 역할
- Consumer : 메시지 소비자

메시지 방향 : Producer -> Broker -> Consumer

> 큐잉 모델 
- Broker 안에 Queue를 준비하여 Producer가 발행한 메시지가 Queue에 담기고, Consumer가 Queue에서 메시지를 추출한다.
- Consumer에서 여러 개의 Consumer가 메시지를 추출할 수 있어 Consumer에 의한 병렬 처리 가능
- 하나의 메시지는 여러 Consumer 중 어느 하나에서 처리한다. (여러 Consumer가 분산 처리로 메시지를 소비)

> Pub/Sub 모델
- 메시지 생산자인 Producer를 'Publisher', 메시지 소비자의 해당 Consumer를 'Subscriber' 라고 지칭
- Publisher가 Subscriber에게 직접 메시지를 보내는 것이 아니라 Broker를 통해 전달
- Publisher는 누가 해당 메시지를 수신하는지 알 수 없고, Broker에 있는 Topic 이라고 불리는 카테고리 안에 메시지를 등록
- 큐잉 모델과는 달리 같은 Topic을 구독하는 여러 Subscriber에게는 동일한 메시지가 전달된다.

- 장점
    - 병렬로 동작하는 복수의 Subscriber에 메시지 전달 가능
- 단점
    - 동일한 메시지에 대한 처리이기 때문에 Broker의 Topic에 축적되는 메시지 그룹 입장에서는 처리 능력을 높이는 효과는 없다.
    

> Producer/Consumer 사이에 Broker를 끼우면 좋은점
1. Broker를 경유함에 따라 Producer와 Consumer를 개별로 접속하는 것을 회피할 수 있다.
2. Producer, Consumer 모두 증가하거나 감소한다고 해도 다른 구성에 영향을 주지 않기 때문에 변경에 용이하다.

> 카프카 메시징 모델
- Consumer를 확장 구성할 수 있도록 'Consumer Group' 이라는 개념 도입
- 여러 Consumer가 동일 Topic을 분산하여 메시지를 읽음으로써 처리의 확장성을 담보
    - Topic A -> 메시지 1 - Consumer Group(Consumer 1) / 메시지 2 - Consumer Group(Consumer 2)
- Broker 의 복수 구성 동작 가능 (Replication 가능)

### 디스크로의 데이터 영속화
- 카프카는 Broker에 보낸 메시지를 Disk에 영속화한다.
- 디스크 영속화를 제공함에도 불구하고 높은 처리량 제공

### 이해하기 쉬운 API 제공
- Producer와 Consumer를 쉽게 접속할 수 있도록 'Connect API' 제공
- API 를 기반으로 카프카에 접속하기 위한 프레임워크로 'Kafka Connect' 제공

### 전달 보증
- At Least Once (적어도 1회는 전달)를 실현하기 위해 'Ack'과 'Offset Commit' 개념 도입
    - Ack : Broker가 메시지를 수신했을 때 Producer에게 수신 완료했다는 응답을 뜻함
    - Offset : Consumer가 Broker로부터 메시지를 받을 때 Consumer가 어디까지 메시지를 받았는지를 관리
    - Offset Commit : Broker로부터 Consumer가 메시지를 받아 정상적으로 처리를 완료한 다음 Offset을 업데이트함으로써 메시지를 재전송할 때도 어디서부터 재전송하면 되는지 판단할 수 있음
- Exactly Once 실현을 위한 '트랜잭션 개념' 도입   