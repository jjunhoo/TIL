# 4.2 InnoDB 스토리지 엔진 아키텍처

> MySQL 스토리지 엔진 중 거의 유일한 `레코드 기반 잠금` 제공하여 `높은 동시성 처리`가 가능하고 `안정적`이며 성능이 뛰어남

- ![img.png](../image/4.9.png)

## 4.2.1 프라이머리 키에 의한 클러스터링

- 모든 테이블은 기본적으로 `Primary Key 를 기준으로 클러스터링`되어 저장
  - Primary Key 값을 기준으로 `정렬된 상태로 데이터가 저장`
- Primary Key 값의 `순서대로 디스크에 저장`
- Primary Key 는 `다른 보조 인덱스에 비해 비중이 높게` 설정
- MyISAM 은 클러스터링 키 미지원 (Primary Key 와 Index 가 구조적으로 동일)

## 4.2.2 외래키 지원

- InnoDB 에서는 외래키로 `부모와 자식 테이블 모두 인덱스를 생성`하고, 데이터가 있는지 체크한다. 이로 인하여 `잠금이 전파되며 데드락이 발생 가능`
- 수동으로 데이터 적재 필요 시, 외래키가 있을 경우 테이블의 관계를 파악해서 순서대로 작업해야하기 때문에 데이터 처리가 어려움
  - 이러한 경우, `foregin_key_checks=off` 로 설정 시, 일시적으로 멈추기 가능
    - 반드시 부모 - 자식 테이블 간 `일관성`을 맞춘 후 on 으로 변경
    - `SET SESSION foregin_key_checks=off;` - SESSION 은 생략 가능
  - `on delete cascade`, `on update cascade` 옵션 무시
- MyISAM 미지원

## 4.2.3 MVCC (Multi Version Concurrency Control)

> Multi Version : 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미

- `잠금을 사용하지 않는 일관된 읽기를 제공`하며, `언두 로그`를 사용하여 구현하며 레코드에 대한 멀티 버전을 제공
- 예 
  > MEMBER 테이블 INSERT 문 실행
    ````sql
    INSERT INTO member (m_id, m_name, m_area) VALUES (12,'홍길동','서울');
    COMMIT;
    ````
  - ![img.png](../image/4.10.png)

  > MEMBER 테이블에 UPDATE 문 실행
    ````sql
    UPDATE member SET m_area = '경기' WHERE m_id = 12；
    ````
    - `버퍼 풀`에 해당 데이터가 갱신된 후, 변경 전 값은 `언두 로그`에 저장
      - 이렇게 하나의 레코드에 대해 여러 개의 버전을 동시에 가지는 것을 `MVCC` 라고 표현
    - 버퍼 풀의 변경된 데이터는 `버퍼의 쓰기작업 후 디스크에 저장`
      - COMMIT : 버퍼 풀 및 디스크의 데이터를 영구적인 데이터로 변경
      - ROLLBACK : 언두 영역의 데이터를 버퍼 풀의 데이터로 복구
    `- ![img.png](../image/4.11.png)`

> COMMIT 이 되지 않은 상태에서 해당 레코드를 조회하면 어떤 영역의 데이터를 반환할까 ?

- READ_UNCOMMITTED : `버퍼 풀`의 값을 반환
- 그 이상의 격리 수준 : `언두 영역`의 값을 반환
  - 언두 영역은 그 영역을 사용한 트랜잭션이 종료될 때 삭제

## 4.2.4 잠금 없는 일관된 읽기 (Non—Locking Consistent Read)

> InnoDB 스토리지 엔진은 MVCC 기술을 이용해 `잠금을 걸지 않고 읽기` 작업을 수행

- SERIALIZABLE 를 제외한 격리 수준은 SELECT 을 잠그지 않아 `다른 트랜잭션의 변경 작업과 관계 없이 바로 실행 가능` (언두 로그의 데이터를 읽는다)
  - READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ
- 언두가 오랫동안 유지될 경우, `성능 저하가 발생`하므로 `트랜잭션은 최소한의 시간동안 유지`
  
- ![img.png](../image/4.12.png)

## 4.2.5 자동 데드락 감지

> 잠금으로 인한 교착 상태를 확인하기 위하여 백그라운드 스레드인 `데드락 감지 스레드`가 잠금 대기 목록을 그래프(Wait-for List)로 관리

- `데드락 감지 스레드`가 주기적으로 잠금 대기 그래프를 검사해 `교착 상태에 빠진 트랜잭션들을 찾아서 그중 하나를 강제 종료`
  - 언두 로그 양을 기준으로 `언두 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상`이 됨 (롤백 시, 언두 처리를 해야할 내용이 적어 서버 부하 최소화)
- InnoDB 스토리지 엔진은 상위 레이어인 MySQL 엔진에서 관리되는 테이블 잠금은 확인 불가
  - `innodb_table_locks`시스템 변수 활성화 시, `InnoDB 스토리지 엔진 내부의 레코드 잠금`뿐만 아니라 `테이블 레벨의 잠금`까지 감지 가능
  - 해당 옵션 활성화 권장
- `동시 처리 스레드가 많아지거나 트랜잭션이 가진 잠금 개수가 많아지면` 데드락 감지 스레드가 CPU 자원을 많이 소모하고 느려짐
  - 이러한 경우, `innodb_deadlock_detect=off` 를 통해 데드락 감지 스레드 비활성화 가능
    - 데드락 감지 스레드 비활성 시, 데드락 상황에서 무한 대기 발생
    - 이때, `innodb_lock_wait_timeout=:50` 시스템 변수를 활성화하면, 데드락 상황에서 잠금 설정 시간 이후 자동으로 요청 실패 및 에러 메시지 반환 (기본값:50초)

## 4.2.6 자동화된 장애 복구

> 서버가 시작될 때 `완료되지 못한 트랜잭션이나 디스크의 일부를 자동으로 복구`하는 기능. 손실이나 장애로부터 데이터를 보호하기 위한 메커니즘

- innoDB 는 매우 견고하여 이런 상황이 거의 발생하지 않음. 보통 서버와 무관한 하드웨어 이슈로 인해 발생하며, 이 문제가 발생하면 보통 쉽게 해결하기 어려움
- 자동 복구를 실패 시, 서버는 실행되지 않음
  - 자동 복구에 실패하였으나 서버 실행이 필요한 경우, `innodb_force_recovery` 를 설정하여 강제 실행 가능
  - 기본값인 0을 제외하고 `1부터 6까지 설정 가능`하며, `낮은 숫자에서 재실행이 가능하다는 의미는 문제의 수준이 낮다는 의미`
- 서버가 실행조차 안된다면, `백업 데이터`와 `바이너리 로그`를 사용하여 복구하는 방법 밖에 없음

## 4.2.7 InnoDB 버퍼 풀

> - 디스크의 데이터 파일이나 인덱스 정보를 `메모리에 캐시`
> - 쓰기 작업을 지연시켜 작업을 `일괄 처리하는 버퍼`

- `INSERT`, `UPDATE`, `DELETE` 처럼 데이터를 변경하는 쿼리는 `데이터 파일의 이곳저곳에 위치한 레코드를 변경`하기 때문에 `랜덤한 디스크 작업을 발생`
  - 버퍼 풀이 이러한 `변경된 데이터를 모아서 처리`하면 `랜덤한 디스크 작업 횟수 감소` 

### 4.2.7.1 버퍼 풀의 크기 설정

- 동적 시스템 변수로서, `innodb_buffer_pool_size` 로 변경
  - 운영체제의 전체 메모리 공간이 8GB 미만이라면 50% 정도 설정
  - 운영체제의 전체 메모리 공간이 8GB 이상이라면 50% 정도 설정 후 최적 찾기
- 버퍼 풀은 전통적으로 버퍼 풀 전체를 관리하는 잠금으로 인해 내부 잠금 경합이 있었지만, 현재는 `여러 개의 버퍼 풀로 분리 및 분산 처리` 중
  - 각 버퍼 풀을 `버퍼 풀 인스턴스`라 표현하며 그 갯수는 `innodb_buffer_pool_instances` 로 설정
    - 기본값 : `8`
    - 메모리 크기가 1GB 미만 인 경우, 강제 `1` 셋팅
    - 메모리 크기가 40GB 이하인 경우, `8` 유지 
    - 메모리 크기가 40GB 초과인 경우, 버퍼 풀 인스턴스 1개당 5GB 정도가 되게 인스턴스 개수 설정 권장
    