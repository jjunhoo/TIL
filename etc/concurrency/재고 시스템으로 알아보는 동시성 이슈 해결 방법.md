## 재고 시스템으로 알아보는 동시성 이슈 해결 방법

재고 시스템에서 발생하는 동시성 이슈를 다음 3가지 방법으로 해결하는 과정 정리

1. synchronized 사용
2. Database Lock 사용
3. Redis 사용

### 1. 실습 환경 

- Springboot
- JPA
- MySQL
- Redis

### 2. 간단한 재고 시스템 로직 

> Stock 감소 로직

````java
@Transactional
public void decrease(Long id, Long quantity) {
    Stock stock = stockRepository.findById(id).orElseThrow();
    stock.decrease(quantity);
}
````

- stock 조회 후 quantity만큼 감소시키는 간단한 로직
- 하지만 여러 Thread 가 동시에 위의 코드를 실행시키게 되면 `Race condition` 발생
  - 이를 해결하기 위해 Thread 하나씩만 접근 가능하도록 처리 필요
 

### 3. 해결 방법 1 : synchronized 사용

> synchronized keyword 추가

````java
@Transactional
public synchronized void decrease(Long id, Long quantity) {
    Stock stock = stockRepository.findById(id).orElseThrow();
    stock.decrease(quantity);
}
````

- 자바에서 자원하는 synchronized를 활용하면 해당 메서드에 Thread 하나씩만 접근하도록 처리 가능
- 하지만 위와 같이 코드를 작성하여도 `@Transactional` 의 동작 방식때문에 문제 발생

> 문제점

````java
// TransactionStockService 예시
private StockService stockService;

public void decrease(Long id, Long quantity) {

    session.beginTransaction(); // 트랜잭션 시작

    stockService.decrease(id, quantity); 

    // 1) 이슈 포인트
    
    session.getTransaction().commit();
    session.close();

}
````

- spring framework 의 `@Transactional` 이 적용된 객체를 대상으로 프록시 적용
- 위와 같이 StockService 의 비즈니스 로직 (decrease) 을 트랜잭션 관련 로직으로 감싼다. (beginTransaction, getTransaction/close)
- decrease 로직에 `synchronized` 가 적용되어 있다고 해도 프록시의 getTransaction/close 이 호출되기 전까지는 데이터베이스에 반영되지 않은 상태
  - 따라서, 상단 코드의 이슈 포인트 부분의 시점에 다른 Thread 가 decrease 로직 실행 가능하기 때문에 동일하게 동시성 이슈 발생 가능

