## 가변 데이터 (Mutable Data)

- 데이터를 변경하다보면 예상치 못했던 결과나 해결하기 어려운 버그가 발생하기도 한다.
- 함수형 프로그래밍 언어는 데이터를 변경하지 않고 복사본을 전달한다. 하지만 그밖의 프로그래밍 언어는 데이터 변경을 허용하고 있다. 
  따라서 변경되는 데이터 사용 시 발생할 수 있는 리스크를 관리할 수 있는 방법을 적용하는 것이 좋다.
- 관련 리팩토링
    - '변수 캡슐화하기 (Encapsulate Variable)' 를 적용해 데이터를 변경할 수 있는 메소드를 제한하고 관리할 수 있다.
    - '변수 쪼개기 (Split Variable)' 를 사용해 여러 데이터를 저장하는 변수를 나눌 수 있다.
    - '코드 정리하기 (Slide Statements)' 를 사용해 데이터를 변경하는 코드를 분리하고 피할 수 있다.
    - '함수 추출하기 (Extract Function)' 으로 데이터를 변경하는 코드로부터 사이드 이팩트가 없는 코드를 분리할 수 있다.
    - '질의 함수와 변경 함수 분리하기 (Separate Query from Modifier)' 를 적용해서 클라이언트가 원하는 경우에만 사이드 이팩트가 있는 함수를 호출하도록 API를 개선할 수 있다.
    - 가능하다면 '세터 제거하기 (Remove Setting Method)' 를 적용한다.
    - 계산해서 알아낼 수 있는 값에는 '파생 변수를 질의 함수로 바꾸기 (Replace Derived Variable with Query)' 를 적용할 수 있다.
    - 변수가 사용되는 범위를 제한하려면 '여러 함수를 클래스로 묶기 (Combine Functions into Class)' 또는 '여러 함수를 변환 함수로 변환 (Combine Functions into Transform)' 을 적용할 수 있다.
    - '참조를 값으로 바꾸기 (Change Reference to Value)' 를 적용해서 데이터 일부를 변경하기 보다는 데이터 전체를 교체할 수 있다.
    
## 리팩토링 18. 변수 쪼개기 (Split Variable)
- 어떤 변수가 여러 번 재할당 되어도 적절한 경우
    - 반복문에서 순회하는데 사용하는 변수 또는 인덱스
    - 값을 축적시키는데 사용하는 변수
        - 예 : StringBuilder - append(), for문 - index
- 그밖의 경우에 재할당 되는 변수가 있다면 해당 변수는 여러 용도로 사용되는 것이며 변수를 분리해야 더 이해하기 좋은 코드를 만들 수 있다.
    - 변수 하나당 하나의 책임(Responsibility)을 지도록 만든다.
    - 상수를 활용하자 (자바스크립트 : const, 자바 : final)
    
````java
// 리팩토링 전
public class Rectangle {
    private double perimeter;
    private double area;
    
    public void updateGeometry(double height, double width) {
        double temp = 2 * (height + width);
        System.out.println("Perimeter : " + temp);
        perimeter = temp;
        
        temp = height * width;
        System.out.println("Area : " + temp);
        area = temp;
    }
    
    public double getPerimeter() {
        return perimeter;
    }
    
    public double getArea() {
        return area;
    }
}
````

````java
// 리팩토링 후
public class Rectangle {
    private double perimeter;
    private double area;
    
    public void updateGeometry(double height, double width) {
        // 변수 하나당 하나의 책임 (기존 temp 변수는 2가지 책임 - perimeter, area)
        final double perimeter = 2 * (height + width); // 보다 구체적이고 명확한 변수명 사용 
        System.out.println("Perimeter : " + perimeter);
        this.perimeter = perimeter;
        
        final double area = height * width; // 보다 구체적이고 명확한 변수명 사용
        System.out.println("Area : " + area);
        this.area = area;
    }
    
    public double getPerimeter() {
        return perimeter;
    }
    
    public double getArea() {
        return area;
    }
}
````

````java
// 리팩토링 전
public class Haggis {
    private double primaryForce;
    private double secondaryForce;
    private double mass;
    private int delay;
    
    public Haggis(double primaryForce, double secondaryForce, double mass, int delay) {
        this.primaryForce = primaryForce;
        this.secondaryForce = secondaryForce;
        this.mass = mass;
        this.delay = delay;
    }
    
    public double distanceTravelled(int time) {
        double result;
        double acc = primaryForce / mass;
        int primaryTime = Math.min(time, delay);
        result = 0.5 * acc * primaryTime * primaryTime;
        
        int secondaryTime = time - delay;
        if (secondaryTime > 0) {
            double primaryVelocity = acc * delay;
            acc = (primaryForce + secondaryForce) / mass;
            result += primaryVelocity * secondaryTime + 0.5 * acc * secondaryTime + secondaryTime;
        }
        
        return result;
    }
}
````

````java
// 리팩토링 후
public class Haggis {
    private double primaryForce;
    private double secondaryForce;
    private double mass;
    private int delay;
    
    public Haggis(double primaryForce, double secondaryForce, double mass, int delay) {
        this.primaryForce = primaryForce;
        this.secondaryForce = secondaryForce;
        this.mass = mass;
        this.delay = delay;
    }
    
    public double distanceTravelled(int time) {
        double result;
        // 변수 하나당 하나의 책임 (기존 acc 변수는 2가지 책임 - primaryAcceleration, secondaryAcceleration)
        final double primaryAcceleration = primaryForce / mass; // 보다 구체적으로 2가지 이상의 책임 변수 구분
        int primaryTime = Math.min(time, delay);
        result = 0.5 * primaryAcceleration * primaryTime * primaryTime;
        
        int secondaryTime = time - delay;
        if (secondaryTime > 0) {
            double primaryVelocity = acc * delay;
            final double secondaryAcceleration = (primaryForce + secondaryForce) / mass; // 보다 구체적으로 2가지 이상의 책임 변수 구분
            result += primaryVelocity * secondaryTime + 0.5 * secondaryAcceleration * secondaryTime + secondaryTime;
        }
        
        return result;
    }
}
````

````java 
// 리팩토링 전
public class Order {
    // inputValue 변수는 파라미터이자 반환값으로 2가지 용도로 사용
    public double discount(double inputValue, int quantity) {
       if (inputValue > 50) inputValue = inputValue - 2;
       if (quantity > 100) inputValue = inputValue - 1;
       return inputValue;
    }
} 
````

````java 
// 리팩토링 후
public class Order {
    public double discount(double inputValue, int quantity) {
        // 보다 명시적으로 result 전용 변수 사용 
        double result = inputValue; 
        if (inputValue > 50) result -= 2;
        if (quantity > 100) result -= 1;
       
        return result;
    }
} 
````

## 리팩토링 19. 질의 함수와 변경 함수 분리하기 (Separate Query from Modifier)
- '눈에 띌만한' 사이드 이펙트 없이 값을 조회할 수 있는 메소드는 테스트 하기도 쉽고, 메소드를 이동하기도 편하다.
- 명령-조회 분리 (command-query separation) 규칙
    - 어떤 값을 리턴하는 함수는 사이드 이펙트가 없어야 한다.
- '눈에 띌만한 (observable) 사이드 이펙트'
    - 가령, Cache는 중요한 객체 상태 변화는 아니다. 따라서 어떤 메소드 호출로 인해, 캐시 데이터를 변경하더라도 분리할 필요는 없다.
    
````java
// 리팩토링 전
public class Billing {
    private Customer customer;
    private EmailGateway emailGateway;
    
    public Billing(Customer customer, EmailGateway emailGateway) {
        this.customer = customer;
        this.emailGateway = emailGateway;
    }
    // 2가지 역할을 하는 메소드 (getTotalOutstanding : 조회, sendBill : 메일 발송) 
    public double getTotalOutstandingAndSendBill() {
        double result = customer.getInvoices().stream()
                .map(Invoice::getAmount)
                .reduce((double) 0, Double::sum);
        sendBill();
        return result;
    }
    
    private void sendBill() {
        emailGateway.send(formatBill(customer));
    }
    
    private String formatBill(Customer customer) {
        return "sending bill for " + customer.getName();   
    }
}
````

````java
// 리팩토링 후
public class Billing {
    private Customer customer;
    private EmailGateway emailGateway;
    
    public Billing(Customer customer, EmailGateway emailGateway) {
        this.customer = customer;
        this.emailGateway = emailGateway;
    }
    // 질의 함수 분리 
    public double getTotalOutstanding() {
        return customer.getInvoices().stream()
                .map(Invoice::getAmount)
                .reduce((double) 0, Double::sum);
    }
    // 변경 함수 분리
    private void sendBill() {
        emailGateway.send(formatBill(customer));
    }
    
    private String formatBill(Customer customer) {
        return "sending bill for " + customer.getName();   
    }
}
````    

````java
// 리팩토링 전
public class Criminal {
    public String alertForMiscreant(List<Person> people) {
        for (People p : people) {
            if (p.getName().equals("Don")) {
                setOffAlarms();
                return "Don";
            }
            if (p.getName().equals("John")) {
                setOffAlarms();
                return "John";
            }
        }
        return "";
    }
    private void setOffAlarms() {
        System.out.println("set off alarm");
    }
}
````

````java
// 리팩토링 후
public class Criminal {
    public String alertForMiscreant(List<Person> people) {
        if (!findMiscreant(people).isBlank()) { // 질의
            setOffAlarms(); // 변경
        }
    }
    // 질의 함수 분리
    public String findMiscreant(List<Person> people) {
        for (Person p : people) {
            if (p.getName().eqauls("Don")) {
                return "Don";
            }
            if (p.getName().eqauls("John")) {
                return "John";
            }
        }
        return "";
    }
    // 변경 함수 분리
    private void setOffAlarms() {
        System.out.println("set off alarm");
    }
}
````

## 리팩토링 20. 세터 제거하기 (Remove Setting Method)

- 세터를 제공한다는 것은 해당 필드가 변경될 수 있다는 것을 뜻한다.
- 객체 생성 시 처음 설정된 값이 변경될 필요가 없다면, 해당 값을 설정할 수 있는 생성자를 만들고 세터를 제거해서 변경될 수 있는 가능성을 제거해야 한다.

````java
// 리팩토링 전
class PersonTest {
    @Test 
    void person() {
        Person person = new Person();
        person.setId(10);
        person.setName("Tom");
        assertEquals(10, person.getId());
        assertEquals("Tom", person.getName());
        person.setName("Bobby");
        assertEquals("Bobby", person.getName());
    }
}

public class Person {
    
    private String name;
    private int id ;
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public void getId() {
        return id;
    }
    
    public void setId(int id) {
        this.id = id;   
    }
}
```` 

````java
// 리팩토링 후
class PersonTest {
    @Test 
    void person() {
        Person person = new Person(10); // 생성자를 통해서만 id 셋팅
        // person.setId(10);
        person.setName("Tom");
        assertEquals(10, person.getId());
        assertEquals("Tom", person.getName());
        person.setName("Bobby");
        assertEquals("Bobby", person.getName());
    }
}

public class Person {
    
    private String name;
    private int id ;
    
    // 생성자 생성 시점에만 id 값을 셋팅 가능
    public Person (int id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public void getId() {
        return id;
    }
    
    /* id 값은 생성 시점에만 셋팅하고, 이후 수정은 불가하도록 하기 위하여 세터 제거 및 생성자 생성
    public void setId(int id) {
        this.id = id;   
    }
    */
}
```` 

## 리팩토링 21. 파생 변수를 질의 함수로 바꾸기 (Replace Derived Variable with Query)

- 변경할 수 있는 데이터를 최대한 줄이도록 노력해야 한다.
- 계산해서 알아낼 수 있는 변수는 제거할 수 있다.
    - 계산 자체가 데이터의 의미를 잘 표현하는 경우도 있다.
    - 해당 변수가 어디선가 잘못된 값으로 수정될 수 있는 가능성을 제거할 수 있다.
- 계산에 필요한 데이터가 변하지 않는 값이라면, 계산의 결과에 해당하는 데이터 역시 불변 데이터기 때문에 해당 변수는 그대로 유지할 수 있다.

````java
// 리팩토링 전
public class Discount {
    private double discountedTotal; // 계산해서 알아낼 수 있는 변수 (Derived Variable)
    private double discount;
    private double baseTotal;
    
    public Discount(double baseTotal) {
        this.baseTotal = baseTotal;
    }
    
    public double getDiscountedTotal() {
        return this.discountedTotal;
    }
    
    public void setDiscount(double number) {
        this.discount = number;
        // 계산해서 알아낼 수 있는 변수
        this.discountedTotal = this.baseTotal - this.discount;
    }
}

public DiscountTest {
    
    @Test 
    void discount() {
        Discount discount = new Discount(100);
        // 해당 시점에는 discount.setDiscount(); 이 호출되지 않았기 때문에 discountedTotal 값이 0 이므로 테스트 실패
        // assertEquals(100, discount.getDiscountedTotal());
        
        discount.setDiscount(10);
        assertEquals(90, discount.getDiscountedTotal()); // 테스트 성공
    } 
}
```` 

````java
// 리팩토링 후
public class Discount {
    // private double discountedTotal; // 계산해서 알아낼 수 있는 변수 제거
    private double discount;
    private double baseTotal;
    
    public Discount(double baseTotal) {
        this.baseTotal = baseTotal;
    }
    
    public double getDiscountedTotal() {
        return this.baseTotal - this.discount;
    }
    
    public void setDiscount(double number) {
        this.discount = number;
        // 계산해서 알아낼 수 있는 변수 제거 
        // this.discountedTotal = this.baseTotal - this.discount;
    }
}

public DiscountTest {
    
    @Test 
    void discount() {
        Discount discount = new Discount(100);
        assertEquals(100, discount.getDiscountedTotal());
        
        discount.setDiscount(10);
        assertEquals(90, discount.getDiscountedTotal());
    } 
}
```` 

````java
// 리팩토링 전
public class ProductionPlan {
    private double production; // 계산해서 알아낼 수 있는 변수 (Derived Variable)
    private List<Double> adjustments = new ArrayList<>();
    
    public void applyAdjustment(double adjustment) {
        this.adjustments.add(adjustment);
        this.production += adjustment;
    }
    
    public double getProduction() {
        return this.production;
    }
}
````

````java
// 리팩토링 후
public class ProductionPlan {
    // private double production; // 계산해서 알아낼 수 있는 변수 제거
    private List<Double> adjustments = new ArrayList<>();
    
    public void applyAdjustment(double adjustment) {
        this.adjustments.add(adjustment);
        // this.production += adjustment;
    }
    
    public double getProduction() {
        // 합계를 getter 호출 시 직접 계산해서 리턴
        return this.adjustments.stream().reduce((double) 0, Double::sum);
    }
}
````