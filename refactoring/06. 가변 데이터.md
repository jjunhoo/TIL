## 가변 데이터 (Mutable Data)

- 데이터를 변경하다보면 예상치 못했던 결과나 해결하기 어려운 버그가 발생하기도 한다.
- 함수형 프로그래밍 언어는 데이터를 변경하지 않고 복사본을 전달한다. 하지만 그밖의 프로그래밍 언어는 데이터 변경을 허용하고 있다. 
  따라서 변경되는 데이터 사용 시 발생할 수 있는 리스크를 관리할 수 있는 방법을 적용하는 것이 좋다.
- 관련 리팩토링
    - '변수 캡슐화하기 (Encapsulate Variable)' 를 적용해 데이터를 변경할 수 있는 메소드를 제한하고 관리할 수 있다.
    - '변수 쪼개기 (Split Variable)' 를 사용해 여러 데이터를 저장하는 변수를 나눌 수 있다.
    - '코드 정리하기 (Slide Statements)' 를 사용해 데이터를 변경하는 코드를 분리하고 피할 수 있다.
    - '함수 추출하기 (Extract Function)' 으로 데이터를 변경하는 코드로부터 사이드 이팩트가 없는 코드를 분리할 수 있다.
    - '질의 함수와 변경 함수 분리하기 (Separate Query from Modifier)' 를 적용해서 클라이언트가 원하는 경우에만 사이드 이팩트가 있는 함수를 호출하도록 API를 개선할 수 있다.
    - 가능하다면 '세터 제거하기 (Remove Setting Method)' 를 적용한다.
    - 계산해서 알아낼 수 있는 값에는 '파생 변수를 질의 함수로 바꾸기 (Replace Derived Variable with Query)' 를 적용할 수 있다.
    - 변수가 사용되는 범위를 제한하려면 '여러 함수를 클래스로 묶기 (Combine Functions into Class)' 또는 '여러 함수를 변환 함수로 변환 (Combine Functions into Transform)' 을 적용할 수 있다.
    - '참조를 값으로 바꾸기 (Change Reference to Value)' 를 적용해서 데이터 일부를 변경하기 보다는 데이터 전체를 교체할 수 있다.
    
## 리팩토링 18. 변수 쪼개기 (Split Variable)
- 어떤 변수가 여러 번 재할당 되어도 적절한 경우
    - 반복문에서 순회하는데 사용하는 변수 또는 인덱스
    - 값을 축적시키는데 사용하는 변수
        - 예 : StringBuilder - append(), for문 - index
- 그밖의 경우에 재할당 되는 변수가 있다면 해당 변수는 여러 용도로 사용되는 것이며 변수를 분리해야 더 이해하기 좋은 코드를 만들 수 있다.
    - 변수 하나당 하나의 책임(Responsibility)을 지도록 만든다.
    - 상수를 활용하자 (자바스크립트 : const, 자바 : final)
    
````java
// 리팩토링 전
public class Rectangle {
    private double perimeter;
    private double area;
    
    public void updateGeometry(double height, double width) {
        double temp = 2 * (height + width);
        System.out.println("Perimeter : " + temp);
        perimeter = temp;
        
        temp = height * width;
        System.out.println("Area : " + temp);
        area = temp;
    }
    
    public double getPerimeter() {
        return perimeter;
    }
    
    public double getArea() {
        return area;
    }
}
````

````java
// 리팩토링 후
public class Rectangle {
    private double perimeter;
    private double area;
    
    public void updateGeometry(double height, double width) {
        // 변수 하나당 하나의 책임 (기존 temp 변수는 2가지 책임 - perimeter, area)
        final double perimeter = 2 * (height + width); // 보다 구체적이고 명확한 변수명 사용 
        System.out.println("Perimeter : " + perimeter);
        this.perimeter = perimeter;
        
        final double area = height * width; // 보다 구체적이고 명확한 변수명 사용
        System.out.println("Area : " + area);
        this.area = area;
    }
    
    public double getPerimeter() {
        return perimeter;
    }
    
    public double getArea() {
        return area;
    }
}
````

````java
// 리팩토링 전
public class Haggis {
    private double primaryForce;
    private double secondaryForce;
    private double mass;
    private int delay;
    
    public Haggis(double primaryForce, double secondaryForce, double mass, int delay) {
        this.primaryForce = primaryForce;
        this.secondaryForce = secondaryForce;
        this.mass = mass;
        this.delay = delay;
    }
    
    public double distanceTravelled(int time) {
        double result;
        double acc = primaryForce / mass;
        int primaryTime = Math.min(time, delay);
        result = 0.5 * acc * primaryTime * primaryTime;
        
        int secondaryTime = time - delay;
        if (secondaryTime > 0) {
            double primaryVelocity = acc * delay;
            acc = (primaryForce + secondaryForce) / mass;
            result += primaryVelocity * secondaryTime + 0.5 * acc * secondaryTime + secondaryTime;
        }
        
        return result;
    }
}
````

````java
// 리팩토링 후
public class Haggis {
    private double primaryForce;
    private double secondaryForce;
    private double mass;
    private int delay;
    
    public Haggis(double primaryForce, double secondaryForce, double mass, int delay) {
        this.primaryForce = primaryForce;
        this.secondaryForce = secondaryForce;
        this.mass = mass;
        this.delay = delay;
    }
    
    public double distanceTravelled(int time) {
        double result;
        // 변수 하나당 하나의 책임 (기존 acc 변수는 2가지 책임 - primaryAcceleration, secondaryAcceleration)
        final double primaryAcceleration = primaryForce / mass; // 보다 구체적으로 2가지 이상의 책임 변수 구분
        int primaryTime = Math.min(time, delay);
        result = 0.5 * primaryAcceleration * primaryTime * primaryTime;
        
        int secondaryTime = time - delay;
        if (secondaryTime > 0) {
            double primaryVelocity = acc * delay;
            final double secondaryAcceleration = (primaryForce + secondaryForce) / mass; // 보다 구체적으로 2가지 이상의 책임 변수 구분
            result += primaryVelocity * secondaryTime + 0.5 * secondaryAcceleration * secondaryTime + secondaryTime;
        }
        
        return result;
    }
}
````

````java 
// 리팩토링 전
public class Order {
    // inputValue 변수는 파라미터이자 반환값으로 2가지 용도로 사용
    public double discount(double inputValue, int quantity) {
       if (inputValue > 50) inputValue = inputValue - 2;
       if (quantity > 100) inputValue = inputValue - 1;
       return inputValue;
    }
} 
````

````java 
// 리팩토링 후
public class Order {
    public double discount(double inputValue, int quantity) {
        // 보다 명시적으로 result 전용 변수 사용 
        double result = inputValue; 
        if (inputValue > 50) result -= 2;
        if (quantity > 100) result -= 1;
       
        return result;
    }
} 
````