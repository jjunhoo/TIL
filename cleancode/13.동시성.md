### 서론

단일 스레드에서 동작하는 코드는 작성하기 쉽다. 잘 동작하는 '것 처럼' 보이는 멀티 스레드 코드를 작성하기도 쉽다.

본 챕터에서는 concurrent 프로그래밍의 필요성, 어려움에 대해 논의하고 그것에 대한 해결 방안과 'clean concurrent code' 를 작성하는 방법,
테스트 방법에 대해서 소개한다.

### 동시성이 필요한 이유 

Concurrency 는 단일 스레드에서 엮여 있던 '무엇을 할 것인가' 와 '언제 끝날 것인가' 간의 의존성을 해소시켜 준다.
이는 처리량과 구조 개선에 도움을 줄 수 있다. 

구조 개선의 좋은 예는 Servlet 모델일 것이다. 이론적으로 Servlet 개발자는 요청을 개별적으로 처리하는 데에만 신경을 쓰며,
요청 큐를 직접 관리하는 부담을 덜 수 있다. 물론, Servlet 이 제공하는 의존성의 해소는 완벽하지 않지만 Servlet 이 제공하는 
구조적인 이점은 그 자체로 가치가 있다.

처리량 또한 향상될 수 있다. 한 유저의 요청을 처리하는 데에 1초가 필요한 시스템을 생각해보자. 이 시스템은 적은 유저가 사용할 경우,
그럭저럭 괜찮은 퍼포먼스를 보여줄 것이다. 하지만 유저가 늘어남에 따라 모든 유저는 자신보다 먼저 도착한 요청이 끝날 때까지 기다려야만 한다.
이러한 경우 Concurrency 가 여러 유저를 동시에 처리함으로써 처리량을 향상시킬 수 있다.

> 미신과 오해

아래는 잘 알려진 미신과 오해에 대한 설명이다.
- Concurrency 는 항상 퍼포먼스를 향상시킨다.
   - Concurrency 는 여러 스레드 혹은 여러 프로세서가 대기 시간을 공유할 수 있는 경우에만 퍼포먼스를 향상시킨다. 하지만 이러한 경우는 드물다.
- Concurrent 프로그램 작성은 시스템의 디자인을 변경시키지 않는다.
   - '무엇' 과 '언제' 를 분리하는 작업은 보통 시스템의 구조에 큰 영향을 미친다.
- Web 이나 EJB 와 같은 컨테이너를 사용한다면 Concurrency 문제들은 신경 쓸 필요가 없다.
   - 컨테이너가 어떤 일을 하는가에 대해 알아야 하며, Concurrent Update, 데드락을 해결하는 방법을 알아야 한다.
   
위에 덧붙여 아래의 사항도 숙지하자.
- Concurrency 는 퍼포먼스, 코드 작성 양쪽 모두에 약간의 오버헤드를 일으킨다.
- 간단한 문제 해결을 위한 Concurrency 는 간단하지 않다.
- Concurrency 관련 버그는 재현하기 어렵기 때문에 종종 one-off (사전적 의미는 "한 번만 일어나는"이며, 여기에서는 "고칠 수 없는"이라는 의미도 포함하고 있다.) 로 취급된다.
- Concurrency 문제에는 보통 근본적인 디자인 개편이 필요하다.

### 난관 

````java
// Code 1-1 
public class ClassWithThreadingProblem {
    private int lastIdUsed;
    
    public ClassWithThreadingProblem(int lastIdUsed) {
        this.lastIdUsed = lastIdUsed;
    }
    
    public int getNextId() {
        return ++lastIdUsed;
    }
}

public static void main(String args[]) {
    final ClassWithThreadingProblem classWithThreadingProblem = new ClassWithThreadingProblem(42);
    
    Runnable runnable = new Runnable() {
        public void run() {
            classWithThreadingProblem.getNextId();
        }
    };
    
    Thread t1 = new Thread(runnable);
    Thread t2 = new Thread(runnable);
    t1.start();
    t2.start(); 
}
````

위 코드가 만들 수 있는 결과는 총 3가지 이다.

t1이 43을, t2가 44를 가져간다. lastIdUsed 는 44이다.(O)
t1이 44을, t2가 43를 가져간다. lastIdUsed 는 44이다.(O)
t1이 43을, t2가 43를 가져간다. lastIdUsed 는 43이다.(X)

위의 getNextId() 메서드는 8개의 자바 byte-code 로 변환되며, 이를 두 스레드에서 실행하게 되면 총 12,870개의 코드 조합을 낼 수 있다. 
그 중 얼마 안 되는 몇몇 조합이 위의 3가지 결과 중 마지막 결과를 낳게 된다.

### 동시성 방어 원칙

단일 책임 원칙 (Single Responsibility Principle - SRP)

Concurrency 디자인은 그 자체로 충분히 복잡하기 때문에 변경이 발생할 수 있다. 따라서 Concurrency 관련 코드는 분리되어야 한다.
하지만 Concurrency 구현은 다른 코드의 변화까지 가져오는 경우가 잦다.
아래의 사항들을 숙지하자.

- Concurrency 관련 코드는 개발, 변경, 튜닝 시 다른 코드와 분리된 생명주기를 갖는다.
- Concurrency 관련 코드는 그 자체가 가지는 어려움(풀기 힘든 문제)이 있다.
- 잘못 작성된 Concurrency 코드는 여러 문제를 발생시킬 수 있으며, 이는 추가적인 코드 없이 해결되기 힘들다.

! 추천 : Concurrency 관련 코드는 다른 코드들과 분리하라.

> 따름 정리 (Corollary) : 자료 범위를 제한하라

공유 객체를 두 쓰레드에서 수정하는 중 간섭이 발생할 수 있으며, 이는 얘기치 못한 결과를 야기할 수 있다.
이러한 critical section 을 보호하는 한 가지 방법은 synchronized 키워드를 사용하는 것이다.
Critical section 의 수는 가능한한 적게 만들어야 하며 이를 어길 경우 아래와 같은 문제가 발생하기 쉽게 된다.

- 한두 군데를 보호하는 것을 까먹기 쉬우며, 이로 인해 해당 자원을 수정하는 모든 코드를 망가뜨리게 된다.
- 모든 곳이 보호되었는지 파악하기 위해 중복적인 노력이 필요하게 된다.
- 이미 찾기 어려운 문제의 근원을 더 찾기 어렵게 만들게 된다.

! 추천 : 데이터 캡슐화를 가슴 깊이 새기며, 공유될만한 자원에 접근하는 부분(코드)을 극도로 줄여라

> 따름 정리 : 자료 사본을 사용하라

공유 자원 문제를 해결하는 좋은 방법중 하나는 애초에 공유 자원을 사용하지 않는 것이다. 읽기 전용으로 사용될 경우 
자원의 복사본을 사용하게 하는 방법이 있다. 경우에 따라서는 복사본을 여러 쓰레드에 전달, 작업을 수행하고 결과를
단일 쓰레드에서 수집해 사용하는 것도 가능하다.

객체의 복사에 드는 비용을 걱정할 수도 있다. 혹은, 이문제가 '진짜 문제가 되는지' 조사해 보는 방법도 있다.
하지만, 객체의 복사본을 사용함으로써 동기화를 피할 수 있다면, 객체 생성 및 GC 에 드는 비용은 공유 자원 동기화에 
필요한 비용 보다 일반적으로 적은 비용으로 문제를 해결하게 해준다. (객체 복사 Cost < 공유 자원 동기화 Cost)

> 따름 정리 : 쓰레드는 가능한 독립적으로 구현하라

쓰레드 코드를 공유 자원을 사용하지 않는 독립된 세계로 만든다면 동기화 문제는 없어지게 된다.

HttpServlet 을 생각해보자. HttpServlet 을 상속받는 클래스는 doGet, doPost 와 같은 메서드에서 필요한 파라미터를 받아
처리한다. 이는 각 Servlet 이 각자의 세계에 있는 것처럼 작동하게 도와주며, 지역 변수를 사용하는 한 동기화 문제는 발생하지 
않게 된다. 물론 대부분의 Servlet 들은 데이터베이스 연결과 같은 공유 자원이 필요하긴 하다.

! 추천 : 데이터를 독립적인 스레드 - 더 나아가 각각의 프로세서에서 사용될 수 있게 구분하라 