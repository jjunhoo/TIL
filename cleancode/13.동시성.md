### 서론

단일 스레드에서 동작하는 코드는 작성하기 쉽다. 잘 동작하는 '것 처럼' 보이는 멀티 스레드 코드를 작성하기도 쉽다.

본 챕터에서는 concurrent 프로그래밍의 필요성, 어려움에 대해 논의하고 그것에 대한 해결 방안과 'clean concurrent code' 를 작성하는 방법,
테스트 방법에 대해서 소개한다.

### 동시성이 필요한 이유 

Concurrency 는 단일 스레드에서 엮여 있던 '무엇을 할 것인가' 와 '언제 끝날 것인가' 간의 의존성을 해소시켜 준다.
이는 처리량과 구조 개선에 도움을 줄 수 있다. 

구조 개선의 좋은 예는 Servlet 모델일 것이다. 이론적으로 Servlet 개발자는 요청을 개별적으로 처리하는 데에만 신경을 쓰며,
요청 큐를 직접 관리하는 부담을 덜 수 있다. 물론, Servlet 이 제공하는 의존성의 해소는 완벽하지 않지만 Servlet 이 제공하는 
구조적인 이점은 그 자체로 가치가 있다.

처리량 또한 향상될 수 있다. 한 유저의 요청을 처리하는 데에 1초가 필요한 시스템을 생각해보자. 이 시스템은 적은 유저가 사용할 경우,
그럭저럭 괜찮은 퍼포먼스를 보여줄 것이다. 하지만 유저가 늘어남에 따라 모든 유저는 자신보다 먼저 도착한 요청이 끝날 때까지 기다려야만 한다.
이러한 경우 Concurrency 가 여러 유저를 동시에 처리함으로써 처리량을 향상시킬 수 있다.

> 미신과 오해

아래는 잘 알려진 미신과 오해에 대한 설명이다.
- Concurrency 는 항상 퍼포먼스를 향상시킨다.
   - Concurrency 는 여러 스레드 혹은 여러 프로세서가 대기 시간을 공유할 수 있는 경우에만 퍼포먼스를 향상시킨다. 하지만 이러한 경우는 드물다.
- Concurrent 프로그램 작성은 시스템의 디자인을 변경시키지 않는다.
   - '무엇' 과 '언제' 를 분리하는 작업은 보통 시스템의 구조에 큰 영향을 미친다.
- Web 이나 EJB 와 같은 컨테이너를 사용한다면 Concurrency 문제들은 신경 쓸 필요가 없다.
   - 컨테이너가 어떤 일을 하는가에 대해 알아야 하며, Concurrent Update, 데드락을 해결하는 방법을 알아야 한다.
   
위에 덧붙여 아래의 사항도 숙지하자.
- Concurrency 는 퍼포먼스, 코드 작성 양쪽 모두에 약간의 오버헤드를 일으킨다.
- 간단한 문제 해결을 위한 Concurrency 는 간단하지 않다.
- Concurrency 관련 버그는 재현하기 어렵기 때문에 종종 one-off (사전적 의미는 "한 번만 일어나는"이며, 여기에서는 "고칠 수 없는"이라는 의미도 포함하고 있다.) 로 취급된다.
- Concurrency 문제에는 보통 근본적인 디자인 개편이 필요하다.

### 난관 

````java
// Code 1-1 
public class ClassWithThreadingProblem {
    private int lastIdUsed;
    
    public ClassWithThreadingProblem(int lastIdUsed) {
        this.lastIdUsed = lastIdUsed;
    }
    
    public int getNextId() {
        return ++lastIdUsed;
    }
}

public static void main(String args[]) {
    final ClassWithThreadingProblem classWithThreadingProblem = new ClassWithThreadingProblem(42);
    
    Runnable runnable = new Runnable() {
        public void run() {
            classWithThreadingProblem.getNextId();
        }
    };
    
    Thread t1 = new Thread(runnable);
    Thread t2 = new Thread(runnable);
    t1.start();
    t2.start(); 
}
````

위 코드가 만들 수 있는 결과는 총 3가지 이다.

t1이 43을, t2가 44를 가져간다. lastIdUsed 는 44이다.(O)
t1이 44을, t2가 43를 가져간다. lastIdUsed 는 44이다.(O)
t1이 43을, t2가 43를 가져간다. lastIdUsed 는 43이다.(X)

위의 getNextId() 메서드는 8개의 자바 byte-code 로 변환되며, 이를 두 스레드에서 실행하게 되면 총 12,870개의 코드 조합을 낼 수 있다. 
그 중 얼마 안 되는 몇몇 조합이 위의 3가지 결과 중 마지막 결과를 낳게 된다.

### 동시성 방어 원칙

단일 책임 원칙 (Single Responsibility Principle - SRP)

Concurrency 디자인은 그 자체로 충분히 복잡하기 때문에 변경이 발생할 수 있다. 따라서 Concurrency 관련 코드는 분리되어야 한다.
하지만 Concurrency 구현은 다른 코드의 변화까지 가져오는 경우가 잦다.
아래의 사항들을 숙지하자.

- Concurrency 관련 코드는 개발, 변경, 튜닝 시 다른 코드와 분리된 생명주기를 갖는다.
- Concurrency 관련 코드는 그 자체가 가지는 어려움(풀기 힘든 문제)이 있다.
- 잘못 작성된 Concurrency 코드는 여러 문제를 발생시킬 수 있으며, 이는 추가적인 코드 없이 해결되기 힘들다.

! 추천 : Concurrency 관련 코드는 다른 코드들과 분리하라.

> 따름 정리 (Corollary) : 자료 범위를 제한하라

공유 객체를 두 쓰레드에서 수정하는 중 간섭이 발생할 수 있으며, 이는 얘기치 못한 결과를 야기할 수 있다.
이러한 critical section 을 보호하는 한 가지 방법은 synchronized 키워드를 사용하는 것이다.
Critical section 의 수는 가능한한 적게 만들어야 하며 이를 어길 경우 아래와 같은 문제가 발생하기 쉽게 된다.

- 한두 군데를 보호하는 것을 까먹기 쉬우며, 이로 인해 해당 자원을 수정하는 모든 코드를 망가뜨리게 된다.
- 모든 곳이 보호되었는지 파악하기 위해 중복적인 노력이 필요하게 된다.
- 이미 찾기 어려운 문제의 근원을 더 찾기 어렵게 만들게 된다.

! 추천 : 데이터 캡슐화를 가슴 깊이 새기며, 공유될만한 자원에 접근하는 부분(코드)을 극도로 줄여라

> 따름 정리 : 자료 사본을 사용하라

공유 자원 문제를 해결하는 좋은 방법중 하나는 애초에 공유 자원을 사용하지 않는 것이다. 읽기 전용으로 사용될 경우 
자원의 복사본을 사용하게 하는 방법이 있다. 경우에 따라서는 복사본을 여러 쓰레드에 전달, 작업을 수행하고 결과를
단일 쓰레드에서 수집해 사용하는 것도 가능하다.

객체의 복사에 드는 비용을 걱정할 수도 있다. 혹은, 이문제가 '진짜 문제가 되는지' 조사해 보는 방법도 있다.
하지만, 객체의 복사본을 사용함으로써 동기화를 피할 수 있다면, 객체 생성 및 GC 에 드는 비용은 공유 자원 동기화에 
필요한 비용 보다 일반적으로 적은 비용으로 문제를 해결하게 해준다. (객체 복사 Cost < 공유 자원 동기화 Cost)

> 따름 정리 : 쓰레드는 가능한 독립적으로 구현하라

쓰레드 코드를 공유 자원을 사용하지 않는 독립된 세계로 만든다면 동기화 문제는 없어지게 된다.

HttpServlet 을 생각해보자. HttpServlet 을 상속받는 클래스는 doGet, doPost 와 같은 메서드에서 필요한 파라미터를 받아
처리한다. 이는 각 Servlet 이 각자의 세계에 있는 것처럼 작동하게 도와주며, 지역 변수를 사용하는 한 동기화 문제는 발생하지 
않게 된다. 물론 대부분의 Servlet 들은 데이터베이스 연결과 같은 공유 자원이 필요하긴 하다.

! 추천 : 데이터를 독립적인 스레드 - 더 나아가 각각의 프로세서에서 사용될 수 있게 구분하라

### 라이브러리를 이해하라

자바 5버전 이상에서 스레드 관련 코드 작성 시 아래의 사항들을 숙지하자

- 자바에서 제공하는 Thread-Safe 컬렉션을 사용하라
- 연관이 없는 태스크들을 수행 시 executor 프레임워크를 사용하라
- 가능하면 Nonblocking 방법을 사용하라
- 몇몇 라이브러리 클래스들은 Thread-Safe 하지 않다.

쓰레드 환경에 안전한 컬렉션

java.util.concurrent 패키지는 멀티 쓰레드 환경에서 사용할 수 있는 컬렉션들을 제공한다.
ConcurrentHashMap 의 경우에는 일반 HashMap 보다 대부분의 상황에서 더 좋은 퍼포먼스를 제공한다.
만약 배포 환경이 자바 5 버전 이상이라면 이 패키지를 활용하자.

아래와 같은 고급 Concurrency 디자인 구현을 위한 컴포넌트들도 숙지하자.

- ReentrantLock : 한 메서드에서 잠그고 다른 메서드에서 해제될 수 있는 lock 이다.
- Semaphore : 전통적인 세마포어 (개수를 셀 수 있는 lock) 의 구현체이다.
- CountDownLatch : 기다리는 모든 쓰레드들을 해제하기 전 특정 횟수의 이벤트가 발생하는 것을 기다리게 할 수 있는 lock 이다. 
모든 쓰레드가 거의 동시에 시작될 수 있게 도와줄 수 있다.

! 추천 : 당신에게 맞는 클래스를 살펴보라. 자바의 경우, java.util.concurrent, java.util.concurrent.atomic, java.util.concurrent.locks 를 살펴보라

### 실행 모델을 이해하라 

- Bound Resources : Concurrent 환경에서 사용되는 고정된 크기의 자원이다. 예시로 데이터베이스 연결, 고정된 크기의 읽기/쓰기 버퍼가 있다.
- Mutual Exclusion : 한 시점에 공유 자원에 접근할 수 있는 스레드는 단 하나이다.
- Starvation : 한 쓰레드 혹은 쓰레드의 그룹이 긴 시간 혹은 영원히 작업을 수행할 수 없게 된다. 
작업의 우선권을 가지는 수행 시간이 짧은 쓰레드가 끝없이 실행된다면 수행 시간이 긴 쓰레드는 굶게 된다.
- Deadlock : 2개 이상의 쓰레드들이 서로의 작업이 끝나기를 기다린다.
각 쓰레드는 서로가 필요로 하는 자원을 점유하고 있으며 필요한 자원을 얻지 못하는 이상 그 누구도 작업을 끝내지 못하게 된다.
- Livelock : 쓰레드들이 서로 작업을 수행하려는 중 다른 쓰레드가 작업중인 것을 인지하고 서로 양보한다.
이러한 공명 때문에 쓰레드들은 작업을 계속 수행하려 하지만 장시간 혹은 영원히 작업을 수행하지 못하게 된다.

> 생산자-소비자 (Producer-Consumer)

1개 이상의 생산자가 생산한 작업물을 버퍼 혹은 큐에 넣는다. 1개 이상의 소비자가 버퍼 혹은 큐에서 작업물을 습득, 작업을 마친다.
생산자와 소비자 사이에 있는 큐는 Bound Resources 이다. 따라서 생산자는 큐에 남는 공간이 생길 때까지, 소비자는 큐에 작업물이
하나라도 생길 떄까지 기다려야 한다. 큐를 통한 생산자와 소비자간의 조율에는 둘 사이의 시그널링이 필요하다. 생산자는 큐에 작업물을 넣고
소비자에게 '큐가 비어있지 않다' 는 신호를 보내고 소비자는 큐에서 작업물을 꺼낸 후 '큐가 가득차 있지 않다' 는 신호를 보낸다.
그 전까지 둘은 신호를 기다린다.

> 읽기-쓰기 (Readers-Writers)

일반적으로 독자를 위한 정보로 사용되며, 가끔 저자에 의해 업데이트되는 공유 자원의 경우 처리량이 문제가 된다.
처리량을 강조해 독자가 상대적인 우선권을 가지게 되면 저자는 기아 상태에 빠지며 공유 자원은 정체된 정보로 가득차게 된다.
반대로 저자가 우선권을 가지면 처리량이 줄어들게 된다. 
저자-독자 문제는 이 둘 사이의 균형을 맞추며 Concurrent 업데이트를 방지하는 것을 주안점으로 둔다.

> 식사하는 철학자들 (Dining Philosophers)

원탁을 둘러싼 여러 명의 철학자들이 있다. 각 철학자의 왼쪽에 포크가 놓여 있으며 테이블의 중앙에 큰 스파게티 한 그릇이 놓여있다.
그들은 배가 고파지기 전까지 각자 생각을 하며 시간을 보낸다. 배가 고파지면 그들은 자신의 양쪽에 놓여 있는 포크 2개를 잡고 스파게티를 먹는다.
철학자는 포크 2개가 있어야만 스파게티를 먹을 수 있다. 그렇지 않다면 옆 사람이 포크를 다 사용하기 전까지 기다려야 한다.
스파게티를 먹은 철학자는 다시 배가 고파질 때까지 포크를 놓고 있게 된다.
위 상황에서 철학자를 쓰레드로, 포크를 공유 자원으로 바꾸게 되면 이는 자원을 놓고 경쟁하는 프로세스와 비슷한 상황이 된다.
잘 설계되지 않은 시스템은 DeadLock, LiveLock, 처리량 문제, 효율성 저하 문제에 맞닥뜨리기 쉽다.

당신이 맞닥뜨릴 대부분의 Concurrent 관련 문제들은 위 3가지 문제의 변형일 가능성이 높다.
이 알고리즘들을 공부하고 스스로 해법을 작성함으로써 이와 같은 문제들을 직면하더라도 의연하게 대처할 수 있도록 하자.