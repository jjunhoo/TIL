### 서론

단일 스레드에서 동작하는 코드는 작성하기 쉽다. 잘 동작하는 '것 처럼' 보이는 멀티 스레드 코드를 작성하기도 쉽다.

본 챕터에서는 concurrent 프로그래밍의 필요성, 어려움에 대해 논의하고 그것에 대한 해결 방안과 'clean concurrent code' 를 작성하는 방법,
테스트 방법에 대해서 소개한다.

### 동시성이 필요한 이유 

Concurrency 는 단일 스레드에서 엮여 있던 '무엇을 할 것인가' 와 '언제 끝날 것인가' 간의 의존성을 해소시켜 준다.
이는 처리량과 구조 개선에 도움을 줄 수 있다. 

구조 개선의 좋은 예는 Servlet 모델일 것이다. 이론적으로 Servlet 개발자는 요청을 개별적으로 처리하는 데에만 신경을 쓰며,
요청 큐를 직접 관리하는 부담을 덜 수 있다. 물론, Servlet 이 제공하는 의존성의 해소는 완벽하지 않지만 Servlet 이 제공하는 
구조적인 이점은 그 자체로 가치가 있다.

처리량 또한 향상될 수 있다. 한 유저의 요청을 처리하는 데에 1초가 필요한 시스템을 생각해보자. 이 시스템은 적은 유저가 사용할 경우,
그럭저럭 괜찮은 퍼포먼스를 보여줄 것이다. 하지만 유저가 늘어남에 따라 모든 유저는 자신보다 먼저 도착한 요청이 끝날 때까지 기다려야만 한다.
이러한 경우 Concurrency 가 여러 유저를 동시에 처리함으로써 처리량을 향상시킬 수 있다.

> 미신과 오해

아래는 잘 알려진 미신과 오해에 대한 설명이다.
- Concurrency 는 항상 퍼포먼스를 향상시킨다.
   - Concurrency 는 여러 스레드 혹은 여러 프로세서가 대기 시간을 공유할 수 있는 경우에만 퍼포먼스를 향상시킨다. 하지만 이러한 경우는 드물다.
- Concurrent 프로그램 작성은 시스템의 디자인을 변경시키지 않는다.
   - '무엇' 과 '언제' 를 분리하는 작업은 보통 시스템의 구조에 큰 영향을 미친다.
- Web 이나 EJB 와 같은 컨테이너를 사용한다면 Concurrency 문제들은 신경 쓸 필요가 없다.
   - 컨테이너가 어떤 일을 하는가에 대해 알아야 하며, Concurrent Update, 데드락을 해결하는 방법을 알아야 한다.
   
위에 덧붙여 아래의 사항도 숙지하자.
- Concurrency 는 퍼포먼스, 코드 작성 양쪽 모두에 약간의 오버헤드를 일으킨다.
- 간단한 문제 해결을 위한 Concurrency 는 간단하지 않다.
- Concurrency 관련 버그는 재현하기 어렵기 때문에 종종 one-off (사전적 의미는 "한 번만 일어나는"이며, 여기에서는 "고칠 수 없는"이라는 의미도 포함하고 있다.) 로 취급된다.
- Concurrency 문제에는 보통 근본적인 디자인 개편이 필요하다.

### 난관 

````java
// Code 1-1 
public class ClassWithThreadingProblem {
    private int lastIdUsed;
    
    public ClassWithThreadingProblem(int lastIdUsed) {
        this.lastIdUsed = lastIdUsed;
    }
    
    public int getNextId() {
        return ++lastIdUsed;
    }
}

public static void main(String args[]) {
    final ClassWithThreadingProblem classWithThreadingProblem = new ClassWithThreadingProblem(42);
    
    Runnable runnable = new Runnable() {
        public void run() {
            classWithThreadingProblem.getNextId();
        }
    };
    
    Thread t1 = new Thread(runnable);
    Thread t2 = new Thread(runnable);
    t1.start();
    t2.start(); 
}
````

위 코드가 만들 수 있는 결과는 총 3가지 이다.

t1이 43을, t2가 44를 가져간다. lastIdUsed 는 44이다.(O)
t1이 44을, t2가 43를 가져간다. lastIdUsed 는 44이다.(O)
t1이 43을, t2가 43를 가져간다. lastIdUsed 는 43이다.(X)

위의 getNextId() 메서드는 8개의 자바 byte-code 로 변환되며, 이를 두 스레드에서 실행하게 되면 총 12,870개의 코드 조합을 낼 수 있다. 
그 중 얼마 안 되는 몇몇 조합이 위의 3가지 결과 중 마지막 결과를 낳게 된다.