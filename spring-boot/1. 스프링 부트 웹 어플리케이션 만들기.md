## 스프링 부트 웹 어플리케이션 만들기

- 2014년 4월 1일, 스프링 부트 1.0 출시

### 스프링 부트란 무엇인가
- 스프링 포트폴리오를 신속하게, 미리 정의된 방식으로, 이식성 있게, 실제 서비스 환경에 사용할 수 있도록 조립해놓은 것

> 신속성
- 의존관계를 포함해서 어플리케이션의 여러 요소에 기반한 의사결정을 신속히 적용할 수 있도록 해줌

> 미리 정의된 방식
- 스프링 부트 구성 설정 시 그 구성에 따른 가정을 통해 기본 설정값이 자동 셋팅

> 이식성
- JDK 가 있는 곳이라면 스프링 부트 어플리케이션은 어디에서나 실행 가능

> 실제 서비스 환경에 사용 가능
- 자바로 만들어진 가장 큰 서비스 중 하나인 넷플릭스에서도 사용

### 리액티브 프로그래밍 소개
- 리액티브 프로그래밍은 1970년대에 관련 학술 자료가 나옴
- 하지만, 주류로 올라서지 못했던 이유는 리액티브 프로그래밍을 써야만 할 정도의 대규모 서비스가 많지 않았기 때문
- 최근에는 기존 자원을 더 효율적이고, 일관성 있게 사용하는 방법으로 '리액티브 스트림' 사용

> 리액티브 스트림 : 발행자(Publisher)와 구독자(Subscriber) 사이의 간단한 계약을 정의하는 명세
- 구독자가 '최대 10개까지 수용 가능'하다고 발행자에게 알리는 방식으로 트래픽 제어 가능. 
    - 그러면 발행자는 실제 10개만 더 보내며 '수요 조절'을 통해 '배압' 적용
    
- 프로젝트 리액터 (Project Reactor)는 VM웨어에서 만든 리액티브 스트림 구현체
- 리액터 특징
    - 논블로킹, 비동기 프로그래밍 모델
    - 함수형 프로그래밍 스타일
    - 스레드를 신경 쓸 필요 없는 동시성
    
### 리액터 타입
- 프로젝트 리액터는 핵심 타입인 Flux<T> 를 사용해서 수요 조절 구현
- Flux<T>는 실제 물건을 전달해주는 역할을 하는 플레이스홀더로 쉽게 말해 레스토랑에서 일하는 서빙 점원과 비슷한 개념
    - 주방에서 요리가 완성되면, 점원이 주방에서 요리를 받아서 손님에게 가져다주고, 다시 제자리로 돌아와서 다음 요리를 기다림
    - 서빙 점원(Flux<T>)은 다음 요리가 주방에서 언제 완성될지 알 수 없음
    - 하지만, 언제가 됐든 요리가 완성되고, 서빙 점원이 그 요리를 받아 전달할 수 있는 상태라면, 서빙 점원은 다음 요리를 손님에게 서빙
    
````java
class KitchenService {
    Flux<Dish> getDishes() {
        // 요리를 담당하는 ChefService를 모델링해서 요리를 위임할 수도 있지만, 단순한 설명을 위해 하드코딩으로 대체
        return Flux.just(
            new Dish("Sesame chicken"),
            new Dish("Lo mein noodles, plain"),
            new Dish("Sweet & sour beef"));
    }
}
````

- 리액터는 '논블록킹' 방식으로 동작
    - 주방에서 요리가 완성될 때까지 서빙 점원(서버 쓰레드)이 다른 일을 못 한 채 계속 기다리게 하지 않음
- 결과가 아직 정해지지 않았고, 미래 어느 시점이 되어야 알 수 있다는 점에서 Flux 는 Future 와 비슷
    - Future는 이미 시작되었음을 나타내는 반면, Flux는 시작할 수 있음을 나타냄
- Flux 특징 
    1. 하나 이상의 Dish(요리) 포함 가능
    2. 각 Dish(요리)가 제공될 때, 어떤 일이 발생하는지 지정 가능
    3. 성공과 실패의 2가지 경로 모두에 대한 처리 방향 정의 가능
    4. 결과 폴링 불필요
    5. 함수형 프로그래밍 지원
    
````java
// 평범한 서빙 점원 클래스 작성
class SimpleServer {
    private final KitchenService kitchen;
    
    SimpleServer(KitchenService kitchen) { // 생성자 주입
        this.kitchen = kitchen;
    }
    
    // doingMyJob() : 서빙 점원이 요리를 주방에서 받아옴
    // map() : 요리 완성 후 해야 할 일 지정
    // deliver() : 요리의 delivered 상태를 'true' 로 설정  
    Flux<Dish> doingMyJob() {
        return this.kitchen.getDishes()
                .map(dish -> Dish.deliver(dish));
    }
}
````

````java
// 친절한 서빙 점원 클래스 작성
class PoliteServer {
    private final KitchenService kitchen;
        
    SimpleServer(KitchenService kitchen) { // 생성자 주입
        this.kitchen = kitchen;
    }
    
    Flux<Dish> doingMyJob() {
        return this.kitchen.getDishes() 
            .doOnNext(dish -> System.out.println("Thank you for " + dish + "!"))
            .doOnError(error -> System.out.println("So sorry about " + error.getMessage()))
            .doOnComplete(() -> System.out.println("Thanks for all your hard work!"))
            .map(Dish::deliver);
    }
}
````

- doOnNext
    - 리액티브 스트림의 onNext() 시그널을 받으면 kitchen 에게 '감사합니다.' 라는 말을 하는 기능 추가
- doOnError 
    - onError() 시그널을 받으면 처리해야 할 일 지정
- doOnComplete
    - doOnComplete() 시그널 (주방에서 모든 요리가 완성됐음을 의미)을 받으면 처리해야 할 일 지정
    
````java
// 구독을 통해 점원이 일하게 만드는 친절한 레스토랑
class PoliteRestaurant {
    public static void main(String... args) {
        PoliteServer server = new PoliteServer(new KitchenService());
    
        // 위 KitchenService 에서는 하드 코딩으로 3개의 요리가 만들어지겠지만, subscribe()를 호출하지 않으면 doingMyJob 을 호출하더라도 아무 일도 일어나지 않음 
        server.doingMyJob().subscribe(
                dish -> System.out.println("Consuming " + dish),
                throwable -> System.err.println(throwable));
    }
}
````

- 리액터 기반 어플리케이션에서는 구독하기 전까지는 아무 일도 일어나지 않음
- 리액터는 태생적으로 지연(Lazy) 방식이며, 누군가 구독하고 결과를 당겨가기(pull) 전까지 아무 일도 일어나지 않음
- subscribe()는 자바 8의 Consumer를 첫 번째 인자로 받아들임 (dish -> System.out.println("Consuming " + dish) 라는 람다식을 받음)
- subscribe()는 두 번째 인자로 throwable -> System.err.println(throwable) 이라는 람다식을 받음

````plain
// 결과
Thank you for Dish(description='Sesame chicken', delivered=false}!
Consuming Dish(description='Sesame chicken', delivered=true}!
Thank you for Dish(description='Lo mein noodles, plain', delivered=false}!
Consuming Dish(description='Lo mein noodles, plain', delivered=true}!
Thank you for Dish(description='Sweet & sour beef', delivered=false}!
Consuming Dish(description='Sweet & sour beef', delivered=true}!
Thanks for all your hard work!
````

### 스프링 웹플럭스의 등장
- 스프링 프레임워크 5.0 이전까지 웹 어플리케이션 개발 시 가장 널리 사용돼온 도구는 스프링 MVC
    - 스프링 프레임워크는 스프링 부트의 바탕을 이룸
    - 스프링 프레임워크 5.0은 리액티브 스트림을 구현한 프로젝트 리액터 도입
- 확장 요구가 커질수록 스프링 웹플럭스를 활용하여 웹 요청을 리액티브하게 처리하는 것이 올바른 선택
    - 스프링 MVC는 자바 서블릿 API 기반 
    - 또한, 서블릿 API는 블록킹 방식으로 동작
    - 서블릿 3.1 이후 비동기 방식을 일부 지원하나 '리액티브 이벤트 루프'와 '배압 시그널' 지원 X
- Netty는 100% '논블록킹', '비동기 웹컨테이너'로서 서블릿 스펙에 구속되지 않음
    - 스프링 웹플럭스는 Netty와 궁합이 잘 맞음
    - 스프링 웹플럭스 사용 시 스프링 MVC의 프로그래밍 모델 그대로 작성한 코드를 Netty 위에서 실행 가능
    
### 스프링 부트로 이커머스 플랫폼 만들기
- 스프링 이니셜라이저 사용 (https://start.spring.io)
    - Project : Maven
    - Language : Java
    - Spring Boot : 2.4.2
    - Group : com.greglturnquist
    - Artifact : hacking-spring-boot-ch1-reactive
    - Name : Hacking Spring Boot Application
    - Description : Demo project for Hacking with Spring Boot
    - Package Name : com.grelturnquist.hackingspringboot.reactive
- 의존관계
    - Spring Reactive Web : 스프링 웹플럭스 + 내장형 Netty
    - Thymeleaf : 템플릿 엔진

### 프로젝트 Parent

````java
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.6.7</version>
    <relativePath/> <!-- Repository에서 parent를 찾는다-->
</parent>
````

- 위와 Spring Starter Parent 적용 시 미리 정의된 여러 가지 속성 정보, 의존관계, 플러그인 상속
- Spring Boot 새 버전 출시 시 Parent의 version 하나만 갱신하면 그에 포함된 모든 라이브러리도 적합한 버전으로 자동 업그레이드
 
