
## 07. 경계 조건: CORRECT 기억법

### `C`onformance: 준수

- 많은 데이터 요소들은 특정 양식을 따라야 한다.
  - 예 : 이메일 주소 emain@domain 형식
- 이메일 주소의 규악을 검증
  - `@ 기호 앞부분을 이름`으로 추출할 수 있다.
  - 이 때 `@ 기호가 없거나 이름이 비어 있는 경우에도 대처`해야 한다.
  - 각 경계조건이 발생헀을 때 어떤 일이 일어나는지 보여줄 수 있는 테스트 코드를 작성해야 한다.
- 양식 있는 문자열 데이터를 검증할 때는 많은 규칙이 필요하다.
  - 복잡한 구조적 데이터의 경우, 테스트 케이스를 조합하면 그 수가 폭발적으로 늘어난다.
- 계좌 번호 같은 필드는 시스템에 있는 수많은 메서드에서 사용되지만 시스템에 입력될 때, 한 번만 검증한다면 이후에는 검사할 필요가 없다.
  - 시스템을 이해하면 불필요한 검사를 줄일 수 있다.

### `O`rder: 순서

- `데이터 순서` 혹은 `커다란 컬렉션에 있는 한 조각의 위치`는 코드가 쉽게 잘못될 수 있는 CORRECT 조건에 해당한다.
  - 예 : 어떤 메서드의 반환값이 오름차순으로 나와야 하는데, 정말 오름차순 순서로 나오는지 확인해 볼 필요가 있다.

### `R`ange: 범위

- 자바 기본형으로 변수를 만들 때, 대부분은 필요한 것보다 훨씬 많은 용량을 가진다.
  - 사람 나이를 표현하는데, int 를 사용하여 나이가 엄청 많거나 음수가 되거나 한다.
- 기본형의 과도한 사용에 대한 코드 냄새를 `기본형 중독(primitive obsession)` 이라 한다.
- 자바 같은 객체 지향 언어의 장점은 `사용자 정의 추상화`를 `클래스로 정의`할 수 있다는 점이다.
- 예를 들어 Bearing 클래스를 통해 `범위를 제약하는 로직`을 캡슐화한 경우
  - 원은 360도이므로 유효하지 않은 `-1` 혹은 `361`을 가지지 못 하도록 제한(또는 예외를 던진다)한다.

### `R`eference: 참조

- 어떤 메서드를 테스트할 때는 다음을 고려해야 한다.
  - 범위를 넘어서는 것을 `참조`하고 있지 않은지
  - `외부 의존성`은 무엇인지
  - `특정 상태에 있는 객체를 의존`하고 있는지 여부
  - `반드시 존재`해야 하는 그 외 다른 조건들
- 예 : 고객의 계정 히스토리를 표시한다면 고객이 로그인해야 하고, 스택의 pop 메서드를 호출할 경우, 스택이 비어 있으면 안 된다.

### `E`xistence: 존재

- 스스로에게 `주어진 값이 존재하는가?`를 물어봄으로써 많은 잠재적인 결함을 발견할 수 있다.
- 호출된 메서드가 null 을 반환하거나, 기대하는 파일이 없거나, 네트워크가 다운되었을 경우, 어떤 일이 일어나는지 확인하는 테스트를 작성하자.

### `C`ardinality: 기수 (집합의 크기)

- `울타리 기둥 오류(fencepost errors)` : 한 끗 차이로 발생하는 수많은 경우 중 한 가지를 의미하며, 종종 한곳 혹은 다른 곳에서 치명적인 상태가 된다.
- `존재(existence)`는 기술적으로 기수(cardinality)의 특수한 경우다.
- 집합을 이루는 값 개수는 다음 세 가지 경우에 흥미롭다. 이를 혹자는 `0-1-n 법칙`이라고 부른다.
    - 0
    - 1
    - 1보다 많은 다수
- 예 : 팬케이크 가게에 판매량 상위 10개의 음식 목록을 유지해야 한다고 한다. 주문이 나올 때마다 이 상위 목록을 갱신하여 실시간으로 결과를 표시하는 경우
    - 목록에 항목이 하나도 없을 때 보고서 출력하기
    - 목록에 항목이 1개만 있을 떄 보고서 출력하기
    - 목록에 항목이 없을 때 1개 항목 추가하기
    - 목록에 항목이 하나만 있을 때 1개 항목 추가하기
    - 목록에 항목이 아직 10개 미만일 때 1개 항목 추가하기
    - 목록에 항목이 이미 10개가 있을 때 1개 항목 추가하기

### `T`ime: 시간

- 시간에 관하여 주의해야 할 측면은 다음과 같다.
    - 상대적 시간 (시간 순서)
    - 절대적 시간 (측정된 시간)
    - 동시성 문제들

- 어떤 인터페이스들은 태생적으로 상태를 가지고 있다. 예를 들어, login()은 logout()에 앞서 호출되어야 한다.
- 메소드들의 호출 순서가 맞지 않았을 때, 어떤 일이 일어날 지 생각해 본다. 예를 들어, 첫 번째와 마지막 순서의 중간을 생략해 본다.
- 상대적 시간은 타임아웃(timeouts) 문제도 포함할 수 있다. 수명이 짧은 자원에 대해 코드가 얼마나 기다릴 수 있는지 결정해야 한다.
- 실패에 대한 또 다른 해결책은 시스템 시계에 의존하는 테스트를 작성하는 것이다.
- 시간에 따라 서서히 퍼지는 문제점 중 하나는 `동시성`과 `동기화된 접근 맥락`에 관한 문제.
    - 동시에 같은 객체를 다수의 스레드가 접근한다면 ?
    - 어떤 전역 혹은 인스턴스 수준의 데이터나 메소드에 동기화를 해야 하는가 ?
