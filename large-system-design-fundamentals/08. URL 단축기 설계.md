## URL 단축기 설계

### 1단계 : 문제 이해 및 설계 범위 확정

- 쓰기 연산 - 매일 1억개의 단축 URL 생성
  - 초당 쓰기 연산 : `1억/24/3600 = 1160`
- URL 단축 서비스 10년간 운영 가정
  - `1억 * 365 * 10 = 3650억` 개 레코드 보관 필요
- 축약 전 URL 평균 길이 100byte
  - 즉, 10년 동안 필요한 저장 용량 : `3650억 * 100 = 36.5TB`

### 2단계 - 개략적 설계안 제시 및 동의 구하기

> API 엔드포인트

- URL 단축기는 기본적으로 2개의 엔드포인트 필요

1. URL 단축용 End-Point
   - 새 단축 URL을 생성하고자 할 때, 단축할 URL을 인자로 넣어 POST 요청

2. URL 리다이렉션 End-Point
   - 단축 URL에 대해 HTTP 요청이 오면 원래의 URL로 보내주기 위해 리다이렉션 URL 반환

> URL Redirection

- HTTP 에서 Redirection 에 관한 Status, Header 제공

[301 Moved Permanently](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/301)
> 요청한 리소스가 Location 헤더에 주어진 URL 로 완전히 옮겨졌다는 것을 나타낸다. 브라우저는 이 페이지로 리다이렉트하고, 검색 엔진은 해당 리소스로 연결되는 링크를 갱신한다. 검색 엔진 최적화의 관점에서는 '원 콘텐츠가 새로운 URL 로 옮겨졌다'(the link-juice is sent to the new URL)고 한다.

- 영구적으로 이전 되었음으로 브라우저에서는 이 응답을 캐시한다. 즉, 단축 URL 로의 request 를 받았을 때 캐시된 데이터가 있다면, 브라우저는 원래 URL 로 요청을 보내게 된다.
- 단축 URL 서버 부하를 줄이고 싶은 경우, 301을 사용하는 것이 좋을 수 있다.

[302 Found](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/302)
> 요청한 리소스가 Location 헤더에 주어진 URL에 일시적으로 이동되었음을 가리킨다. 브라우저는 사용자를 이 URL의 페이지로 리다이렉트시키지만 검색 엔진은 그 리소스가 일시적으로 이동되었다고 해서 그에 대한 링크를 갱신하지는 않는다. 'SEO 관점' 에서 말하자면, 링크 주스(Link Juice)가 새로운 URL로 보내지지는 않는다.

- 일시적으로 이전 됐음을 나타내므로 캐시되지 않는다. 즉, 단축 URL 로의 request 는 언제나 단축 URL 서버로 보내진 뒤 원래 URL 로 redirection 된다.
- 트래픽 분석 등 단축 URL 서버에서 모든 요청을 받아보는 것이 유의미한 경우, 302를 사용하는 것이 좋을 수 있다.

> URL redirection 을 구현하는 가장 직관적인 방법은 해시 테이블을 사용하는 것 (단축 URL → 원래 URL)

### URL 단축 

- URL 을 단축시키는데 해시 함수 사용
  - 중요한 것은 어떤 해시 함수를 사용할 것인가 ?
- 요구사항
  - URL 이 다르면, 당연히 해시 값도 달라야 한다.
  - 해시 값은 원래의 URL 로 복원될 수 있어야 한다.

### 3단계 - 상세 설계

> 데이터 모델

- 개략적 설계 때는 원래 URL, 단축 URL 을 해시 테이블에 구성
  - 데이터 양이 많아지게 되면, RDB 에 저장하는 방향으로 설계

> 해시 함수

1. 해시 값 길이
- 단축 URL 은 알파벳과 숫자로만 이루어져야한다는 요구사항
  - [0-9, a-z, A-Z]. 즉, 62개의 문자 사용 가능

2. hashValue(단축 URL)의 길이는 몇으로 정할까 ?
- hashValue 의 길이를 정하기 위해서는 `62^n >= 3650억` 에서의 n의 최소값을 찾아야 함.
- n이 7이면 `3.5조` 개의 URL 생성 가능 → hashValue 의 길이를 `7` 로 결정

> 해시 함수 구현 #1. 특정 해시 함수 사용 → 충돌 해결

- 원래의 URL 을 7글자로 줄이는 해시 함수 필요
  - 책에서는 `CRC32`, `MD5`, `SHA-1` 함수 언급 → 하지만 모두 결과가 7글자보단 길다.
- 해시 함수의 결과에서 앞자리 7개만 사용하자
  - 충돌이 발생한 경우, 미리 사전에 정의해 둔 문자열을 원래의 URL 에 추가해 다시 해시 함수 실행. 충돌나지 않을 때까지 반복.
  - 충돌 발생 여부를 확인하기 위해 원래의 URL 과 단축 URL 을 저장한 DB 에서 조회 필요 → 작업 당 충돌 발생 여부 확인을 위해 1번 이상의 쿼리 무조건 발생 → 오버헤드 발생
  - `블룸 필터` 사용 - 어떤 집합에 특정 원소가 있는지 검사
- ![img.png](image/img84.png)

> 해시 함수 구현 #2. base-62 사용

- hashValue 에 사용 가능한 문자가 62개이기 때문에 사용
- 따로 본래의 값을 해시 함수에 넣어 결과를 가져오는 것이 아니라 ID 값을 base-62로 변환해 해당 값을 단축 URL 로 사용
  - 즉, `유일성 보장 ID 생성기` 필요
- 유일성 보장 ID를 단순히 전환하는 것이기에 충돌날 염려는 없지만, ID가 1씩 증가하여 `다음 단축 URL 이 예측 가능`한 보안적인 문제가 발생할 수 있고, `유일성 보장 ID가 길어짐과 비례해서 단축 URL 길이가 길어진다.`

> URL 단축기 상세 설계 (base-62 사용)

1. 원래의 URL 입력
2. DB 에 원래 URL 존재 유무 확인 (단축 URL 존재 유무 확인)
3. 단축 URL 미존재 시, 새로운 ID를 생성 (유일성 보장 ID)
4. 생성된 ID를 단축 URL 로 변환
5. 원래 URL, 단축 URL 을 DB 에 저장 및 반환

### 4단계 - 마무리

> 더 논의해보면 좋을 내용

1. `처리율 제한 장치[4장]` 의 사용
- 엄청난 양의 URL 단축 요청으로 무력화 가능
- IP 주소 등을 통해 필터링 해서 앞단에서 요청 필터를 통한 방어

2. 웹 서버/데이터베이스 규모 확장
- 웹 서버 : scale-out
- 데이터베이스 : 다중화 또는 샤딩

3. 데이터 분석 솔루션 사용
- 302 -> URL 단축 서버로 요청을 받을 수 있음
- 어떤 링크를 얼마나 많은 사용자가 선택했는지? 언제 주로 클릭했는지? 등 확인 가능