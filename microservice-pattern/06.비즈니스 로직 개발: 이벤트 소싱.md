## 이벤트 소싱 응용 비즈니스 로직 개발 

1. 장점
- Aggregate 이력이 보존되므로 감사/통제 용도 사용 가능하다.
- 도메인 이벤트를 확실하게 발행할 수 있다.

2. 단점
- 비즈니스 로직 작성 방법이 까다로워 학습 시간이 필요하다.
- 이벤트 저장소를 쿼리하기 쉽지 않아 CQRS 를 적용해야 한다.


### 기존 영속화의 문제점
- 기존 영속화 방식 : 클래스는 DB 테이블에 클래스 필드는 테이블 컬럼에, 클래스 인스턴스는 테이블 각 로우에 매핑
- 일반적으로 JPA 같은 ORM 프레임워크나 MyBATIS 등의 저수준 프레임워크 사용

> 문제점 

1. 객체-관계 임피던스 부정합
2. Aggregate 이력이 없다.
3. 감사 Logging 을 구현하기 힘들다.
4. 이벤트 발행 로직이 비즈니스 로직에 추가된다.

#### 객체-관계 임피던스 부정합
- 테이블 형태의 '관계형 스키마' 관계가 복잡한 '리치 도메인 모델'
- 임피던스 정합 : 전자공학에서 성질이 완전히 다른 전자 회로가 접속하는 것으로 이런 의미에서 객체와 관계라는 
애초부터 기본 철학과 구조가 다른 둘 사이의 부조화
- 리치 도메인 : 도메인과 관련된 비즈니스 로직을 직접 도메인 객체에 넣은 도메인 모델 

#### Aggregate 이력이 없다
- 기존 영속화 메커니즘은 현재 Aggregate 의 상태만 저장
- 따라서, Aggregate 가 업데이트 되면 이전 상태는 저장되지 않음
- 그렇기 때문에 이력 관리를 위하여는 개발자가 직접 코드를 구현해야 함

#### 감사 Logging 을 구현하기 힘들다
- 많은 Application 은 어느 사용자가 Aggregate 를 변경했는지 Log 를 남겨 추적
- 감사 Logging 은 구현하는데 시간이 걸리는 것도 문제이지만, 
감사 Logging 코드, 비즈니스 로직이 분화하기 때문에 버그가 발생할 가능이 높다

#### 이벤트 발행 로직이 비즈니스 로직에 추가된다
- 도메인 이벤트 발행을 지원하지 않는다.
- 따라서, 감사 Logging 과 같이 개발자가 직접 이벤트 생성 로직을 추가해야함
   
   
### 이벤트 소싱 개요  

> 이벤트 소싱 : 이벤트를 위주로 비즈니스 로직을 구현하고, Aggregate를 DB에 일련의 이벤트로 저장하는 기법 

#### 이벤트를 이용하여 Aggregate 를 저장
- Order - Aggregate를 이벤트 소싱으로 저장한다면, EVENTS 테이블에 여러 ROW로 저장
- 각 ROW는 '주문 생성됨', '주문 승인됨', '주문 배달됨' 등의 도메인 이벤트

|event_id|event_type|entity_type|entity_id|event_data
|---|---|---|---|---|
|102|Order Created|Order|101|{...}|
|103|Order Approved|Order|101|{...}|
|104|Order Shipped|Order|101|{...}|
|105|Order Delivered|Order|101|{...}|

#### 이벤트는 곧 상태 변화
- 도메인 이벤트는 Aggregate의 변경을 구독자에게 알리는 장치
- 이벤트는 Aggregate ID 같은 최소한의 필수 데이터만 넣거나 Consumer 에 유용한 데이터까지 포함시켜 강화 가능 
- 예 : OrderShippedEvent - 데이터는 없고 상태 전이만 나타냄
- 예 : OrderCreateEvent - 주문 품목, 지불 정보, 배달 정보 등의 Consumer 에 유용한 데이터 포함 필수

#### Aggregate 메서드의 관심사는 오직 이벤트
- process() : 요청을 나타낸 커맨드 객체를 매개변수로 받아 상태를 어떻게 변경해야 할지 결정 (1개)
- apply() : 각자 정해진 이벤트 타입을 매개변수로 받아 Aggregate 를 업데이트 (1개 이상)

### 동시 업데이트 : 낙관적 잠금
- 기존 영속화 메커니즘은 대게 한 트랜잭션이 다른 트랜잭션의 변경을 덮어 쓰지 못하게 낙관적 잠금을 하여 처리 (버전 컬럼을 이용하여 마지막으로 Aggregate를 읽은 이후 변경되었는지 감지)
````java
UPDATE AGGREGATE_ROOT_TABLE
SET VERSION = VERSION + 1...
WHERE VERSION = <원본버전>
````
- 이벤트 소싱 역시 낙관적 잠금 기법으로 동시 업데이트를 처리 (이벤트ID 또는 별도의 이벤트 저장소에서 관리하는 버전 번호)

### 이벤트 소싱과 이벤트 발행
- 이벤트 소싱 기반의 Application에서도 폴링, 트랜잭션 로그 테일링 등의 방법으로 이벤트를 발행할 수 있지만, 
이벤트를 OUTBOX 테이블에 잠깐 저장 후 지우는 것이 아니라 EVENTS 테이블에 영구 저장하는 차이점이 있다.

### 스냅샷으로 성능 개선
- 주기적으로 Aggregate 상태의 스냅샷을 저장하고, 가장 최근에 뜬 스냅샷과 그 이후 발생한 이벤트만 가져오는 방식으로 Aggregate 상태를 복원
- 스냅샷 버전이 N이면, N+1 이후에 발생한 이벤트만 가져오면 Aggregate 상태를 되살릴 수 있기 때문에 이전 이벤트 N개는 가져올 필요가 없음

### 멱등한 메시지 처리
- 서비스는 다른 Application 또는 서비스로부터 받은 메시지를 소비 (Aggregate가 발행한 도메인 이벤트 또는 SAGA 오케스트레이터가 보낸 커맨드 메시지 소비)
- 이 과정에서 메시지 브로커가 동일한 메시지를 여러 번 전송할 가능성이 있으므로 메시지 컨슈머는 멱등하게 개발해야함 (메시지 컨슈머가 동일한 메시지를 여러 번 호출해도 안전하다면 멱등한 것)

> RDBMS 이벤트 저장소 사용
- 메시지ID 는 PROCESSED_MESSAGES 테이블에 적재
- 이벤트는 EVENTS 테이블에 적재 
- 이벤트 처리 시 PROCESSED_MESSAGES 테이블을 조회하여 메시지ID 있는 경우, 중복 처리

> NoSQL 이벤트 저장소 사용
- Aggregate가 이벤트를 발생시키지 않을 경우, 오직 메시지ID를 기록할 목적으로 가짜 이벤트 저장
- 이벤트 컨슈머는 가짜 이벤트를 무시   

### 이벤트 소싱의 장점

> 도메인 이벤트를 확실하게 발행

> Aggregate 이력 보존

> O/R 임피던스 불일치 문제 방지

> 개발자에게 타임 머신 제공