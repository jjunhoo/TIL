마이크로서비스 아키텍처에서는 다음 2가지 패턴으로 쿼리를 구현한다.

> API 조합 (Composition) 패턴
서비스 클라이언트가 데이터를 가진 여러 서비스를 직접 호출하여 그 결과를 조합하는 패턴 (구현 간단) 

> CQRS (Command Query Responsibility Segregation) 패턴 
쿼리만 지원하는 하나 이상의 뷰 전용 DB를 유지하는 패턴 (구현 복잡)

## API 조합 패턴 응용 쿼리 

### findOrder() 쿼리
- findOrder()는 기본키로 주문 정보를 조회하는 메서드
- orderId를 매개변수로 받아 주문 내역이 포함된 OrderDetails (주문, 주방, 배달, 회계 서비스) 객체 반환
- 모바일 또는 Web Application 등의 Front-End 모듈에서 findOrder() 호출 
- 모놀리틱 아키텍쳐에서는 SELECT 문으로 여러 테이블을 JOIN해서 주문 내역을 조회하면 되지만, 마이크로서비스 아키텍처로 전환하면 데이터가 여러 서비스에 흩어짐

### API 조합 패턴 개요
API 조합 패턴은 데이터를 가진 서비스를 호출한 후 그 반환 결과를 조합해서 가져오며, 이 과정에서 두 종류의 참여자가 개입한다.
- API 조합기
    - Provider 서비스를 쿼리하여 데이터를 조회
- Provider 서비스
    - 최종 결과로 반환할 데이터의 일부를 갖고 있는 서비스

![캡처](https://miro.medium.com/max/948/0*2U6Qtq-ZGbYlxXZC.png)

### API를 조합 패턴으로 findOrder() 쿼리 구현
finderOrder()는 단순히 기본키(orderId)로 EQUI JOIN해서 쿼리하는 작업
> EQUI JOIN : JOIN 대상이 되는 두 테이블에서 공통적으로 존재하는 컬럼의 값이 일치되는 행을 연결하여 결과를 생성하는 JOIN 기법

- 주문 검색 조합기 (API 조합기) : GET /orders/{orderId}
- 주문 서비스 (Provider 서비스) : GET /orders/{orderId}
- 주방 서비스 (Provider 서비스) : GET /tickets?orderId={orderId}
- 배달 서비스 (Provider 서비스) : GET /deliveries?orderId={orderId}
- 회계 서비스 (Provider 서비스) : GET /charge?orderId={orderId}

REST 끝점 GET /order/{orderId}가 구현된 주문 검색 조합기는 orderId로 4가지 서비스를 호출한 후 수신한 응답을 JOIN 한다.

### API 조합 설계 이슈
1. 어느 컴포넌트를 쿼리 작업의 API 조합기로 선정할 것인가 ?
2. 어떻게 해야 효율적으로 취합 로직을 작성할 것인가 ? 

> 누가 API 조합기 역할을 맡을 것인가 ? 
1. 서비스 클라이언트를 API 조합기로 사용
    - 클라이언트가 동일한 LAN에서 실행 중인 경우 효율적
2. Application의 외부 API가 구현된 API 게이트웨이를 API 조합기로 사용
    - 쿼리 작업이 Application의 외부 API 중 일부인 경우 효율적
3. API 조합기를 Stand-Alone 서비스로 구현
    - 내부적으로 여러 서비스가 사용하는 Qeury 작업인 경우 효율적

> API 조합기는 리액티브 프로그래밍 모델을 사용해야 한다
- 쿼리 작업의 반응 시간을 최대한 줄이려면 가능한 한 API 조합기가 Provider 서비스를 병렬 호출해야 한다.
- 하지만, 어떤 Provider 서비스를 호출하기 위해 다른 Provider 서비스의 결과를 먼저 가져와야 하는 경우도 있는데, 이런 경우 일부 Provider 서비스를 순차 호출해야 한다.
- 관리가 용이하고 성능/확장성도 우수한 API 조합기를 작성하려면 Java - ComputableFuture, RxJava - observable 과 같은 리액티브 설계 기법을 동원해야 한다.

### API 조합 패턴의 장단점
1. 오버헤드 증가
2. 가용성 저하 우려
3. 데이터 일관성 결여

> 오버헤드 증가 
- 모놀리틱은 클라이언트가 요청 1번으로 필요한 데이터를 조회하지만, API 조합 패턴은 여러 번 요청하고 여러 DB 쿼리를 실행해야 하므로 그만큼 컴퓨팅/네트워크 리소스가 더 많이 소모되고 Application 운영 비용도 늘어난다.

> 가용성 저하 우려
- 어떤 작업의 가용성은 더 많은 서비스가 개입할수록 감소한다. (feat. 3장)
- 하나의 쿼리 작업에 3가지 (API 조합기 + 둘 이상의 Provider) 서비스가 개입되는 구조기 때문에 하나의 서비스로 처리하는 것에 비해 가용성이 현저히 낮다.

- 가용성을 높이는 전략 
    1. Provider 서비스가 불능일 경우, API 조합기가 이전에 Cache 한 데이터를 반환
    2. API 조합기가 미완성된 데이터를 반환

> 데이터 일관성 결여
- API 조합 패턴은 여러 DB를 대상으로 여러 쿼리를 실행하기 때문에 일관되지 않은 데이터가 반환될 수 있다.
- 효율적으로 구현하기 어려운 쿼리 작업은 CQRS 패턴으로 구현하는 편이 바람직  

## CQRS 패턴
- CQRS 패턴은 API 조합 패턴으로는 효율적으로 구현하기 어려운 쿼리 때문에 각광받기 시작
- Enterprise Application은 대부분 RDBMS에 트랜잭션을 걸어 레코드를 관리하고, 텍스트 검색 쿼리는 Elasticsearch나 Solar 등의 텍스트 검색 DB를 이용하여 구현한다. 
    1. RDBMS와 텍스트 검색 DB를 모두 출력하여 동기화 
    2. 주기적으로 RDBMS에서 텍스트 검색 DB로 데이터를 복사
- 여러 서비스에 있는 데이터를 가져오는 쿼리는 이벤트를 이용하여 해당 서비스의 데이터를 복제한 읽기 전용 뷰를 유지한다.
![캡처](https://miro.medium.com/max/1302/0*cPXPYQBtSmjsX3Ht.png)

### CQRS의 필요성
- API 조합 패턴만으로는 효율적으로 구현하기 어려운 다중 서비스 쿼리가 많으며, 단일 서비스 쿼리조차도 구현하기 어려운 경우도 있다.

> findOrderHistory() 쿼리 구현 - API 조합 패턴으로 구현하기 어려운 다중 서비스 쿼리
- findOrderHistory()는 다음의 매개변수를 받아 소비자의 '주문 이력'을 조회하는 다건 주문 목록 반환 쿼리 작업
    - consumerId : 소비자 식별자
    - OrderHistoryFilter : 필터 조건, 어느 시점 이후 주문까지 반환할 것인지(필수), 주문 상태(옵션), 음식점명 및 메뉴 항목을 검색할 키워드(옵션)

> 예 : 배달, 회계 서비스 같은 Provider는 필터 속성을 저장하지 않기 때문에 API를 조합해서 소비자 주문 데이터를 효율적으로 가져오기 어려움
- 주문 검색 조합기 (API 조합기) : GET /orders?consumerId=&keyword=
- 주문 서비스 (Provider 서비스) : GET /orders?consumerId=&keyword=
- 주방 서비스 (Provider 서비스) : GET /tickets?consumerId=&keyword=
- 배달 서비스 (Provider 서비스) : GET /deliveries?consumerId=
- 회계 서비스 (Provider 서비스) : GET /charge?consumerId=

> API 조합기 문제 해결 방법
1. API 조합기로 데이터 In-Memory 조인
    - 어떤 소비자의 모든 주문 데이터를 배달 서비스, 회계 서비스에서 가져온 후 주문 서비스, 주방 서비스에서 가져온 데이터와 JOIN
    - 하지만, API 조합기에서 거대한 데이터 뭉치들을 이러한 방식으로 조인하면 효율이 급격히 저하된다.
2. API 조합기로 주문 서비스, 주방 서비스에서 데이터를 조회하고, 주문ID를 이용하여 다른 서비스에 있는 데이터 요청
    - 하지만, 이는 해당 서비스가 대량 조회 API를 제공할 경우에만 현실성 있는 방법이며, 주문 데이터를 하나하나 요청하는 것은 과도한 네트워크 트래픽을 유발하므로 비효율적 

### CQRS 개요

> CQRS는 커맨드와 쿼리를 서로 분리한다.
- CQRS는 관심사의 분리/구분에 관한 패턴으로 영속적 데이터 모델과 그것을 사용하는 모듈을 커맨드와 쿼리, 두 편으로 가른다.
- 조회(Read) 기능은 쿼리 쪽 모듈 및 데이터 모델에, 생성/수정/삭제(Create, Update, Delete) 기능은 커맨드 쪽 모듈 및 데이터 모델에 구현한다.
- 양쪽 데이터 모델 사이의 동기화는 커맨드 쪽에서 발행한 이벤트를 쿼리 쪽에서 구독하는 식으로 이루어진다.
    - CUD용 DB와 Read용 DB를 따로두고, 커맨드 쪽 DB가 변경될 때마다 발행되는 이벤트를 구독(이벤츄에이트 트램, 이벤트 소싱)하여 항상 최신 상태를 유지

> CQRS와 쿼리 전용 서비스
- 쿼리 서비스에는 커맨드 작업이 전혀 없는 오직 쿼리 작업만으로 구성된 API가 있다.
- 하나 이상의 다른 서비스가 발행한 이벤트를 구독하여 항상 최신 상태로 유지되는 DB를 쿼리하는 로직이 구현되어 있다.
- 쿼리 쪽 서비스는 여러 서비스가 발행한 이벤트를 구독해서 구축된 뷰를 구현하기 좋은 방법 (예 : 주문, 주방, 배달, 회계 서비스에서 발생한 이벤트를 구독하여 내부 '주문  이력 뷰 DB' 적재)

### CQRS의 장점
1. 마이크로서비스 아키텍처에서 쿼리를 효율적인 쿼리가 가능
2. 다양한 쿼리를 효율적으로 구현 가능
3. 이벤트 소싱 어플리케이션에서 쿼리가 가능
4. 관심사가 더 분리

> 마이크로서비스 아키텍처에서 쿼리를 효율적인 쿼리가 가능
- CQRS 패턴은 여러 서비스의 데이터를 조회하는 쿼리를 효율적으로 구현할 수 있게 해주며, 여러 서비스에서 데이터를 미리 조인해 놓는 CQRS 뷰를 이용하는 것이 간편하고 효율적이다.

> 다양한 쿼리를 효율적으로 구현 가능
- 단일 영속화 데이터 모델만으로는 갖가지 종류의 쿼리를 지원하기가 쉽지 않으며, 불가능한 경우도 있다.
- CQRS 패턴을 이용하면 각 쿼리가 효율적으로 구현된 하나 이상의 뷰를 정의하여 단일 데이터 저장소의 한계를 극복할 수 있다.

> 이벤트 소싱 어플리케이션에서 쿼리가 가능
- CQRS 패턴은 하나 이상의 Aggregate 뷰를 정의하고, 이벤트 소싱 기반의 Aggregate가 발행한 이벤트 스트림을 구독해서 항상 최신 상태를 유지

> 관심사가 더 분리
- 도메인 모델과 그에 대응되는 여속화 데이터 모델은 커맨드, 쿼리를 모두 처리하지 않는다.
- CQRS 패턴은 서비스의 커맨드 쪽, 쿼리 쪽에 각각 알맞은 코드 모듈과 DB 스키마를 별도 정의한다.

### CQRS의 단점
1. 아키텍처가 더 복잡하다
2. 복제 시차(Replication Lag)를 처리해야 한다.

> 아키텍처가 더 복잡하다
- 개발자는 뷰를 조회/수정하는 쿼리 서비스를 작성해야 하며, 별도의 데이터 저장소를 관리해야 하는 운영 복잡도 역시 가중됨

> 복제 시차를 처리해야 한다
- 커맨드/쿼리 양쪽 뷰 사이의 '시차'를 처리해야 한다.
- 커맨드 쪽이 이벤트를 발행하는 시점과 쿼리 쪽이 이벤트를 받아 뷰를 업데이트하는 시점 사이의 지연

## CQRS 뷰 설계
- 이벤트 핸들러, 쿼리 API 모듈은 데이터 접근 모듈을 통해 DB를 조회/수정한다.
- 이벤트 핸들러 모듈은 이벤트를 구독해서 DB를 업데이트하고, 쿼리 API 모듈은 데이터를 조회한다.

- 뷰 모듈 개발 시 중요 설계 결정 사항
    1. DB 선정 및 스키마 설계
    2. 데이터 접근 모듈을 설계할 때 멱등성/동시 업데이트 등 다양한 문제 고려
    3. 기존 어플리케이션에 새로운 뷰를 구현하거나 기존 스키마를 바꿀 경우, 뷰를 효율적으로 빌드할 수 있는 수단 강구
    4. 뷰 클라이언트에서 복제 시차를 어떻게 처리할지에 대한 대책
    
### 뷰 DB 선택
> SQL vs NoSQL 
- NoSQL은 대부분 트랜잭션 기능이 제한적이고 범용적인 쿼리 능력은 없지만, 어떠한 유스케이스에서는 유연한 데이터 모델, 우수한 성능/확장성 등이 기존 SQL 보다 더 낫다.
- NoSQL은 풍성한 데이터 모델과 우수한 성능으로 CQRS 뷰에 유리
- CQRS 뷰는 단순 트랜잭션만 사용하고 고정된 쿼리만 실행하므로 NoSQL의 제약 사항에도 영향을 받지 않음
- 하지만, 대부분의 개발자, DBA, IT운영자가 SQL 에 익숙하며, 리포팅 엔진 때문에 어쩔 수 없이 SQL 을 사용해야 하는 경우도 있음 

### 데이터 접근 모듈 설계 
> 동시성 처리
- 뷰가 여러 종류의 Aggregate가 발행한 이벤트를 구독할 경우, 여러 이벤트 핸들러가 동일한 레코드에 달려들어 업데이트할 수 있다.

#### 동시성 예시 
1. 동일한 주문을 대상으로 Order 이벤트 핸들러와 Delivery 이벤트 핸들러가 동일한 시간에 호출 되어 해당 주문의 DB 레코드를 업데이트하는 DAO가 동시 호출
2. DAO가 레코드를 읽고 업데이트된 레코드를 쓴다면 '낙관적 잠금' 또는 '비관적 잠금' 둘 중 하나를 적용해야 함

> 멱등한 이벤트 핸들러
- 이벤트 핸들러는 같은 이벤트를 한 번 이상 넘겨받고 호출될 수 있음
- 쿼리 쪽 이벤트 핸들러가 멱등한 경우, 중복 이벤트를 처리해도 결과가 정확히 동일하다면 문제되지 않음
- <span style="color:red">비멱등적 이벤트 핸들러는 자신이 뷰 데이터 저장소에서 처리한 이벤트ID를 기록해 두었다가 중복 이벤트가 들어오면 솎아 내야한다.</span>

> 클라이언트 어플리케이션이 최종 일관된 뷰를 사용할 수 있다.
- CQRS 적용 시 커맨드 쪽을 업데이트한 직후 쿼리를 실행하는 클라이언트가 자신이 업데이트 한 내용을 바라보지 못하게 될 가능성이 있다.  
- 하지만, 커맨드와 쿼리 모듈 API 이용 시 클라이언트가 비일관성을 감지 가능하도록 만들 수 있다.

> 커맨드/쿼리 모듈 비일관성 감지 방법 
1. 커맨드 쪽 작업 완료 후 클라이언트에 발행된 이벤트 ID가 포함된 토큰 반환
2. 클라이언트는 이 토큰을 쿼리 작업에 전달 
3. 해당 이벤트에 의해 뷰가 업데이트 되지 않았을 경우, ERROR 반환

### CQRS 뷰 추가 및 업데이트

> 아카이빙된 이벤트를 이용하여 CQRS 뷰 구축
- 메시지 브로커는 메시지를 무기한 보관할 수 없음 (RabbitMQ, Apache Kafka)
- 따라서, AWS S3 같은 곳에 아카이빙된 더 오래된 이벤트를 가져와 사용해야 함 

> CQRS 뷰를 단계적으로 구축
- 전체 이벤트를 처리하는 시간/리소스가 점점 증가
- 따라서, 2단계 증분 알고리즘 적용 필요 
- 1단계 : 주기적으로 각 Aggregate 인스턴스의 스냅샷을 그 이전의 스냅샷과 이 스냅샷이 생성된 이후 발생한 이벤트를 바탕으로 계산
- 2단계 : 계산된 스냅샷과 그 이후 발생한 이벤트를 이용하여 뷰 생성

  




