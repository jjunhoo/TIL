마이크로서비스 아키텍처에서는 다음 2가지 패턴으로 쿼리를 구현한다.

> API 조합 (Composition) 패턴
서비스 클라이언트가 데이터를 가진 여러 서비스를 직접 호출하여 그 결과를 조합하는 패턴 (구현 간단) 

> CQRS (Command Query Responsibility Segregation) 패턴 
쿼리만 지원하는 하나 이상의 뷰 전용 DB를 유지하는 패턴 (구현 복잡)

## API 조합 패턴 응용 쿼리 

### findOrder() 쿼리
- findOrder()는 기본키로 주문 정보를 조회하는 메서드
- orderId를 매개변수로 받아 주문 내역이 포함된 OrderDetails (주문, 주방, 배달, 회계 서비스) 객체 반환
- 모바일 또는 Web Application 등의 Front-End 모듈에서 findOrder() 호출 
- 모놀리틱 아키텍쳐에서는 SELECT 문으로 여러 테이블을 JOIN해서 주문 내역을 조회하면 되지만, 마이크로서비스 아키텍처로 전환하면 데이터가 여러 서비스에 흩어짐

### API 조합 패턴 개요
API 조합 패턴은 데이터를 가진 서비스를 호출한 후 그 반환 결과를 조합해서 가져오며, 이 과정에서 두 종류의 참여자가 개입한다.
- API 조합기
    - Provider 서비스를 쿼리하여 데이터를 조회
- Provider 서비스
    - 최종 결과로 반환할 데이터의 일부를 갖고 있는 서비스

![캡처](https://miro.medium.com/max/948/0*2U6Qtq-ZGbYlxXZC.png)

### API를 조합 패턴으로 findOrder() 쿼리 구현
finderOrder()는 단순히 기본키(orderId)로 EQUI JOIN해서 쿼리하는 작업
> EQUI JOIN : JOIN 대상이 되는 두 테이블에서 공통적으로 존재하는 컬럼의 값이 일치되는 행을 연결하여 결과를 생성하는 JOIN 기법

- 주문 검색 조합기 (API 조합기) : GET /orders/{orderId}
- 주문 서비스 (Provider 서비스) : GET /orders/{orderId}
- 주방 서비스 (Provider 서비스) : GET /tickets?orderId={orderId}
- 배달 서비스 (Provider 서비스) : GET /deliveries?orderId={orderId}
- 회계 서비스 (Provider 서비스) : GET /charge?orderId={orderId}

REST 끝점 GET /order/{orderId}가 구현된 주문 검색 조합기는 orderId로 4가지 서비스를 호출한 후 수신한 응답을 JOIN 한다.

### API 조합 설계 이슈
1. 어느 컴포넌트를 쿼리 작업의 API 조합기로 선정할 것인가 ?
2. 어떻게 해야 효율적으로 취합 로직을 작성할 것인가 ? 

> 누가 API 조합기 역할을 맡을 것인가 ? 
1. 서비스 클라이언트를 API 조합기로 사용
    - 클라이언트가 동일한 LAN에서 실행 중인 경우 효율적
2. Application의 외부 API가 구현된 API 게이트웨이를 API 조합기로 사용
    - 쿼리 작업이 Application의 외부 API 중 일부인 경우 효율적
3. API 조합기를 Stand-Alone 서비스로 구현
    - 내부적으로 여러 서비스가 사용하는 Qeury 작업인 경우 효율적

> API 조합기는 리액티브 프로그래밍 모델을 사용해야 한다
- 쿼리 작업의 반응 시간을 최대한 줄이려면 가능한 한 API 조합기가 Provider 서비스를 병렬 호출해야 한다.
- 하지만, 어떤 Provider 서비스를 호출하기 위해 다른 Provider 서비스의 결과를 먼저 가져와야 하는 경우도 있는데, 이런 경우 일부 Provider 서비스를 순차 호출해야 한다.
- 관리가 용이하고 성능/확장성도 우수한 API 조합기를 작성하려면 Java - ComputableFuture, RxJava - observable 과 같은 리액티브 설계 기법을 동원해야 한다.

### API 조합 패턴의 장단점
1. 오버헤드 증가
2. 가용성 저하 우려
3. 데이터 일관성 결여

> 오버헤드 증가 
- 모놀리틱은 클라이언트가 요청 1번으로 필요한 데이터를 조회하지만, API 조합 패턴은 여러 번 요청하고 여러 DB 쿼리를 실행해야 하므로 그만큼 컴퓨팅/네트워크 리소스가 더 많이 소모되고 Application 운영 비용도 늘어난다.

> 가용성 저하 우려
- 어떤 작업의 가용성은 더 많은 서비스가 개입할수록 감소한다. (feat. 3장)
- 하나의 쿼리 작업에 3가지 (API 조합기 + 둘 이상의 Provider) 서비스가 개입되는 구조기 때문에 하나의 서비스로 처리하는 것에 비해 가용성이 현저히 낮다.

- 가용성을 높이는 전략 
    1. Provider 서비스가 불능일 경우, API 조합기가 이전에 Cache 한 데이터를 반환
    2. API 조합기가 미완성된 데이터를 반환

> 데이터 일관성 결여
- API 조합 패턴은 여러 DB를 대상으로 여러 쿼리를 실행하기 때문에 일관되지 않은 데이터가 반환될 수 있다.
- 효율적으로 구현하기 어려운 쿼리 작업은 CQRS 패턴으로 구현하는 편이 바람직  

## CQRS 패턴
- CQRS 패턴은 API 조합 패턴으로는 효율적으로 구현하기 어려운 쿼리 때문에 각광받기 시작
- Enterprise Application은 대부분 RDBMS에 트랜잭션을 걸어 레코드를 관리하고, 텍스트 검색 쿼리는 Elasticsearch나 Solar 등의 텍스트 검색 DB를 이용하여 구현한다. 
    1. RDBMS와 텍스트 검색 DB를 모두 출력하여 동기화 
    2. 주기적으로 RDBMS에서 텍스트 검색 DB로 데이터를 복사
- 여러 서비스에 있는 데이터를 가져오는 쿼리는 이벤트를 이용하여 해당 서비스의 데이터를 복제한 읽기 전용 뷰를 유지한다.
![캡처](https://miro.medium.com/max/1302/0*cPXPYQBtSmjsX3Ht.png)

### CQRS의 필요성
- API 조합 패턴만으로는 효율적으로 구현하기 어려운 다중 서비스 쿼리가 많으며, 단일 서비스 쿼리조차도 구현하기 어려운 경우도 있다.

> findOrderHistory() 쿼리 구현 - API 조합 패턴으로 구현하기 어려운 다중 서비스 쿼리
- findOrderHistory()는 다음의 매개변수를 받아 소비자의 '주문 이력'을 조회하는 다건 주문 목록 반환 쿼리 작업
    - consumerId : 소비자 식별자
    - OrderHistoryFilter : 필터 조건, 어느 시점 이후 주문까지 반환할 것인지(필수), 주문 상태(옵션), 음식점명 및 메뉴 항목을 검색할 키워드(옵션)

> 예 : 배달, 회계 서비스 같은 Provider는 필터 속성을 저장하지 않기 때문에 API를 조합해서 소비자 주문 데이터를 효율적으로 가져오기 어려움
- 주문 검색 조합기 (API 조합기) : GET /orders?consumerId=&keyword=
- 주문 서비스 (Provider 서비스) : GET /orders?consumerId=&keyword=
- 주방 서비스 (Provider 서비스) : GET /tickets?consumerId=&keyword=
- 배달 서비스 (Provider 서비스) : GET /deliveries?consumerId=
- 회계 서비스 (Provider 서비스) : GET /charge?consumerId=

> API 조합기 문제 해결 방법
1. API 조합기로 데이터 In-Memory 조인
    - 어떤 소비자의 모든 주문 데이터를 배달 서비스, 회계 서비스에서 가져온 후 주문 서비스, 주방 서비스에서 가져온 데이터와 JOIN
    - 하지만, API 조합기에서 거대한 데이터 뭉치들을 이러한 방식으로 조인하면 효율이 급격히 저하된다.
2. API 조합기로 주문 서비스, 주방 서비스에서 데이터를 조회하고, 주문ID를 이용하여 다른 서비스에 있는 데이터 요청
    - 하지만, 이는 해당 서비스가 대량 조회 API를 제공할 경우에만 현실성 있는 방법이며, 주문 데이터를 하나하나 요청하는 것은 과도한 네트워크 트래픽을 유발하므로 비효율적 








