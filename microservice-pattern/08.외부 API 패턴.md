# 외부 API 패턴

1. API 게이트웨이 
2. BFF 

## 외부 API 설계 이슈
FTGO 어플리케이션의 서비스 API를 소비하는 4종류의 클라이언트 
1. 웹 어플리케이션 (일반 소비자/음식점 전용 UI, 내부 관리자용 UI)
2. 자바스크립트 어플리케이션 (브라우저에서 실행)
3. 아이폰/안드로이드 앱 (소비자용/배달원용 모바일 앱)
4. 서드파티 어플리케이션
 
<img src="https://media.vlpt.us/images/litien/post/9f055438-bfa0-44c1-a40a-ceb9745da328/image.png">
   
- 웹 어플리케이션은 방화벽 내부에서 실행되기 때문에 대역폭이 높고, 지연 시간이 짧은 LAN을 통해 서비스에 접속
- 다른 클라이언트(브라우저, 모바일 앱, 서드파티 어플리케이션)는 방화벽 외부에 있으므로 상대적으로 대역폭이 낮고, 지연이 높은 인터넷 또는 모바일 네트워크 환경에서 서비스에 접근

- 클라이언트가 서비스를 직접 호출하도록 API를 설계할 경우 다음과 같은 단점 발생
    1. 클라이언트가 필요한 데이터를 가져오기 위해 여러 번 요청 필요 (서비스 API가 여러 개로 나누어져 있기 때문)
    2. 클라이언트가 서비스 및 API를 알아야 하는 구조 (캡슐화 X)
    3. 클라이언트가 사용하기 불편하거나 실용적이지 못한 IPC를 서비스에서 사용 중인 경우가 있음 (특히 방화벽 외부에 있는 클라이언트)

### API 설계 이슈 : FTGO 모바일 클라이언트
- 가정 : 소비자가 모바일 클라이언트에 접속해서 확인할 수 있는 주문 조회 뷰 개발
    - 모놀리틱 구조에서는 주문 내역을 반환하는 End-Point 요청 한 번으로 조회 가능
    - 마이크로서비스 구조에서는 주문 데이터가 여러 서비스에 분산
        - 만약 모바일 클라이언트가 서비스를 직접 호출하는 구조인 경우, 필요한 데이터를 얻기 위한 각 서비스들을 여러 번 호출하여 데이터를 가져와야 함
        
- 모바일 앱이 API 조합기 역할을 하는 경우 문제점
    > 클라이언트가 요청을 여러 번 전송하기 때문에 UX가 나빠진다
    - 어플리케이션과 서비스 간 상호 작용이 너무 자주 발생할 경우, 어플리케이션이 멎은 것처럼 보일 수 있음
    
    > 캡슐화가 되지 않아 프론트엔드 개발자가 백엔드와 맞물려 코드를 변경해야 한다
    - 백엔드 서비스에 관한 지식이 모바일 앱에 포함되어 있으면 서비스 API를 변경하기가 곤란해질 수 있음
    - 각 서비스들의 End-Point 들에 대한 정보를 알아야 함 
    
    > 클라이언트에 비친화적인 IPC를 사용 중인 클라이언트도 있다
    - 방화벽 외부에서 동작하는 클라이언트 어플리케이션은 대부분 HTTP, Web Socket과 같은 프로토콜 사용
    - 하지만, gRPC, AMQP 와 같은 프로토콜을 사용하는 서비스도 있을 수 있는데, 이런 종류의 프로토콜은 내부에서는 잘 작동 되지만 모바일 클라이언트가 소비하기 어려운 경우가 많음
    
### API 설계 이슈 : 다른 종류의 클라이언트
> 웹 어플리케이션이 API 조합기 역할을 하는 경우 문제점
- 방화벽 내부에서 실행되고 LAN을 통해 서비스에 접근
- 웹에 비친화적인 프로토콜로도 서비스에 접근 가능
- 따라서, 웹 어플리케이션이 직접 백엔드 서비스에 접근하는 것은 별다른 이슈가 없음
    
> 브라우저 기반의 자바스크립트 어플리케이션이 API 조합기 역할을 하는 경우 문제점
- 인터넷을 통해 서비스에 접근하기 때문에 네트워크 지연 문제 발생
- 브라우저 기반의 UI는 모바일 앱보다 더 많은 서비스를 조합해야 할 필요가 있기 때문에 서비스 API를 효율적으로 조합하기 힘듦

> 서드파티 어플리케이션

## API 게이트웨이 패턴
- 클라이언트가 서비스에 직접 접근하면 위와 같은 문제점들이 발생하므로 API 게이트웨이를 사용하는 것이 더 나은 방법

### API 게이트웨이 패턴 개요
- API 게이트웨이는 방화벽 외부의 클라이언트가 어플리케이션 API 요청을 하는 단일 창구 역할을 하는 서비스
- 클라이언트로부터 내부 어플리케이션 아키텍처를 캡슐화하고, API를 제공
- 인증, 모니터링, 사용량 제한 등의 부수적 역할도 담당

> 요청 라우팅
- 요청이 들어오면 API 게이트웨이가 라우팅 맵을 찾아보고 어느 서비스로 요청을 보낼지 결정
- 라우팅 맵 : HTTP 메서드와 서비스 HTTP URL 매핑 

> API 조합         
- API 게이트웨이는 요청 한 번으로 필요한 데이터를 조회할 수 있도록 대단위 API를 제공 (API 조합기 역할 수행)
    예 : 모바일 클라이언트에서 getOrderDetails() 로 API 게이트웨이를 한 번만 요청하면 데이터 조회 가능
    
> 프로토콜 변환
- REST와 gRPC를 혼용할 경우에도 외부 클라이언트에는 REST API 제공 가능 (내부 로직에서 프로토콜 변환)

> 클라이언트마다 적합한 API 제공
- 클라이언트에 맞춤 API 제공 가능 (모바일 : 모바일 요건에 맞게 설계된 API)

> 엣지 기능 구현
- 인증 : 요청한 클라이언트의 신원 확인 (계정)
- 인가 : 특정 작업을 수행하도록 허가받은 클라이언트인지 확인 (권한) 
- 사용량 제한 : 특정 클라이언트의 초당 요청 개수 제한
- 캐싱 : 서비스 요청 횟수를 줄이고자 응답 캐시
- 지표 수집 : API 사용 지표 수집
- 요청 로깅 : 요청 기록

> API 게이트웨이 아키텍처
- API 게이트웨이는 'API 계층'과 '공통 계층' 으로 구성된 모듈 아키텍처 구조
- 클라이언트별 API (모바일, 브라우저, 서드파티)는 별도 모듈로 구현하고, 인증과 같이 전체 API에 필요한 기능은 공통 계층에 구현

> API 게이트웨이 소유권 모델
- API 게이트웨이 개발/운영은 API 게이트웨이 전담 팀 신설하고, 해당 팀은 공통 모듈 개발 및 게이트웨이 운영에 집중
- API가 표출된 모듈은 해당 클라이언트 (모바일, 웹 API팀) 팀이 오너십을 갖는 구조가 바람직 (게이트웨이 팀과의 커뮤니케이션 비용 절감)

> 프론트엔드 패턴을 위한 백엔드
- API 모듈을 각 클라이언트 팀들이 오너십을 가지고 개발하면서 운영은 게이트웨이팀이 하는 경우 책임 소재 불분명
- 따라서, 각 API 모듈을 하나의 클라이언트 팀이 개발/운영하는 BFF (Backends For Frontend) 패턴 적용 필요 
<img src="https://blog.kakaocdn.net/dn/bDyQ71/btral6QWj9r/NSPqGu3JiyX8TMvHVkRdK0/img.png"/>

