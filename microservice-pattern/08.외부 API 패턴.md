# 외부 API 패턴

1. API 게이트웨이 
2. BFF 

## 외부 API 설계 이슈
FTGO 어플리케이션의 서비스 API를 소비하는 4종류의 클라이언트 
1. 웹 어플리케이션 (일반 소비자/음식점 전용 UI, 내부 관리자용 UI)
2. 자바스크립트 어플리케이션 (브라우저에서 실행)
3. 아이폰/안드로이드 앱 (소비자용/배달원용 모바일 앱)
4. 서드파티 어플리케이션
 
<img src="https://media.vlpt.us/images/litien/post/9f055438-bfa0-44c1-a40a-ceb9745da328/image.png">
   
- 웹 어플리케이션은 방화벽 내부에서 실행되기 때문에 대역폭이 높고, 지연 시간이 짧은 LAN을 통해 서비스에 접속
- 다른 클라이언트(브라우저, 모바일 앱, 서드파티 어플리케이션)는 방화벽 외부에 있으므로 상대적으로 대역폭이 낮고, 지연이 높은 인터넷 또는 모바일 네트워크 환경에서 서비스에 접근

- 클라이언트가 서비스를 직접 호출하도록 API를 설계할 경우 다음과 같은 단점 발생
    1. 클라이언트가 필요한 데이터를 가져오기 위해 여러 번 요청 필요 (서비스 API가 여러 개로 나누어져 있기 때문)
    2. 클라이언트가 서비스 및 API를 알아야 하는 구조 (캡슐화 X)
    3. 클라이언트가 사용하기 불편하거나 실용적이지 못한 IPC를 서비스에서 사용 중인 경우가 있음 (특히 방화벽 외부에 있는 클라이언트)

### API 설계 이슈 : FTGO 모바일 클라이언트
- 가정 : 소비자가 모바일 클라이언트에 접속해서 확인할 수 있는 주문 조회 뷰 개발
    - 모놀리틱 구조에서는 주문 내역을 반환하는 End-Point 요청 한 번으로 조회 가능
    - 마이크로서비스 구조에서는 주문 데이터가 여러 서비스에 분산
        - 만약 모바일 클라이언트가 서비스를 직접 호출하는 구조인 경우, 필요한 데이터를 얻기 위한 각 서비스들을 여러 번 호출하여 데이터를 가져와야 함
        
- 모바일 앱이 API 조합기 역할을 하는 경우 문제점
    > 클라이언트가 요청을 여러 번 전송하기 때문에 UX가 나빠진다
    - 어플리케이션과 서비스 간 상호 작용이 너무 자주 발생할 경우, 어플리케이션이 멎은 것처럼 보일 수 있음
    
    > 캡슐화가 되지 않아 프론트엔드 개발자가 백엔드와 맞물려 코드를 변경해야 한다
    - 백엔드 서비스에 관한 지식이 모바일 앱에 포함되어 있으면 서비스 API를 변경하기가 곤란해질 수 있음
    - 각 서비스들의 End-Point 들에 대한 정보를 알아야 함 
    
    > 클라이언트에 비친화적인 IPC를 사용 중인 클라이언트도 있다
    - 방화벽 외부에서 동작하는 클라이언트 어플리케이션은 대부분 HTTP, Web Socket과 같은 프로토콜 사용
    - 하지만, gRPC, AMQP 와 같은 프로토콜을 사용하는 서비스도 있을 수 있는데, 이런 종류의 프로토콜은 내부에서는 잘 작동 되지만 모바일 클라이언트가 소비하기 어려운 경우가 많음
    
### API 설계 이슈 : 다른 종류의 클라이언트
> 웹 어플리케이션이 API 조합기 역할을 하는 경우 문제점
- 방화벽 내부에서 실행되고 LAN을 통해 서비스에 접근
- 웹에 비친화적인 프로토콜로도 서비스에 접근 가능
- 따라서, 웹 어플리케이션이 직접 백엔드 서비스에 접근하는 것은 별다른 이슈가 없음
    
> 브라우저 기반의 자바스크립트 어플리케이션이 API 조합기 역할을 하는 경우 문제점
- 인터넷을 통해 서비스에 접근하기 때문에 네트워크 지연 문제 발생
- 브라우저 기반의 UI는 모바일 앱보다 더 많은 서비스를 조합해야 할 필요가 있기 때문에 서비스 API를 효율적으로 조합하기 힘듦

> 서드파티 어플리케이션

## API 게이트웨이 패턴
- 클라이언트가 서비스에 직접 접근하면 위와 같은 문제점들이 발생하므로 API 게이트웨이를 사용하는 것이 더 나은 방법

### API 게이트웨이 패턴 개요
- API 게이트웨이는 방화벽 외부의 클라이언트가 어플리케이션 API 요청을 하는 단일 창구 역할을 하는 서비스
- 클라이언트로부터 내부 어플리케이션 아키텍처를 캡슐화하고, API를 제공
- 인증, 모니터링, 사용량 제한 등의 부수적 역할도 담당

> 요청 라우팅
- 요청이 들어오면 API 게이트웨이가 라우팅 맵을 찾아보고 어느 서비스로 요청을 보낼지 결정
- 라우팅 맵 : HTTP 메서드와 서비스 HTTP URL 매핑 

> API 조합         
- API 게이트웨이는 요청 한 번으로 필요한 데이터를 조회할 수 있도록 대단위 API를 제공 (API 조합기 역할 수행)
    예 : 모바일 클라이언트에서 getOrderDetails() 로 API 게이트웨이를 한 번만 요청하면 데이터 조회 가능
    
> 프로토콜 변환
- REST와 gRPC를 혼용할 경우에도 외부 클라이언트에는 REST API 제공 가능 (내부 로직에서 프로토콜 변환)

> 클라이언트마다 적합한 API 제공
- 클라이언트에 맞춤 API 제공 가능 (모바일 : 모바일 요건에 맞게 설계된 API)

> 엣지 기능 구현
- 인증 : 요청한 클라이언트의 신원 확인 (계정)
- 인가 : 특정 작업을 수행하도록 허가받은 클라이언트인지 확인 (권한) 
- 사용량 제한 : 특정 클라이언트의 초당 요청 개수 제한
- 캐싱 : 서비스 요청 횟수를 줄이고자 응답 캐시
- 지표 수집 : API 사용 지표 수집
- 요청 로깅 : 요청 기록

> API 게이트웨이 아키텍처
- API 게이트웨이는 'API 계층'과 '공통 계층' 으로 구성된 모듈 아키텍처 구조
- 클라이언트별 API (모바일, 브라우저, 서드파티)는 별도 모듈로 구현하고, 인증과 같이 전체 API에 필요한 기능은 공통 계층에 구현

> API 게이트웨이 소유권 모델
- API 게이트웨이 개발/운영은 API 게이트웨이 전담 팀 신설하고, 해당 팀은 공통 모듈 개발 및 게이트웨이 운영에 집중
- API가 표출된 모듈은 해당 클라이언트 (모바일, 웹 API팀) 팀이 오너십을 갖는 구조가 바람직 (게이트웨이 팀과의 커뮤니케이션 비용 절감)

> 프론트엔드 패턴을 위한 백엔드
- API 모듈을 각 클라이언트 팀들이 오너십을 가지고 개발하면서 운영은 게이트웨이팀이 하는 경우 책임 소재 불분명
- 따라서, 각 API 모듈을 하나의 클라이언트 팀이 개발/운영하는 BFF (Backends For Frontend) 패턴 적용 필요 
<img src="https://blog.kakaocdn.net/dn/bDyQ71/btral6QWj9r/NSPqGu3JiyX8TMvHVkRdK0/img.png"/>

### API 게이트웨이의 장단점
> API 게이트웨이의 장점
- API 게이트웨이의 가장 큰 장점은 어플리케이션의 내부 구조를 캡슐화하는 것
    - 클라이언트가 특정 서비스를 호출할 필요 없이 무조건 게이트웨이를 통해 통신
    
> API 게이트웨이의 단점
- 개발, 배포, 관리해야 하는 고가용 컴포넌트가 하나 더 늘어나는 부담을 감수해야 함
    - 개발자가 자신의 서비스 API를 표출하려면 반드시 API 게이트웨이를 업데이트 해야 함
- 하지만, 이러한 단점들은 BFF 패턴을 적용하면 팀별로 API를 독립적으로 개발/배포할 수 있으니 API 게이트웨이를 사용하는 편이 유리

### API 게이트웨이 사례 : 넷플릭스
- 넷플릭스는 최초에 스트리밍 서비스 API를 만능 스타일로 개발하고자 했지만, 기기 종류가 워낙 광범위하고 요건도 제각각이었기 때문에 다른 방법이 필요하다고 판단
    - 따라서, 현재는 기기별 API가 따로 구현된 API 게이트웨이를 사용하며, API 구현 코드는 클라이언트 기기 팀이 소유 및 개발
    - 넷플릭스 팔코 (Falcor) 를 사용하여 서비스 API 를 표출한 API 게이트웨이를 호출
        - 넷플릭스 팔코 : 선언적으로 API를 동적 조합하는 API 기술
        
### API 게이트웨이 설계 이슈
> API 게이트웨이 설계 시 아래와 같은 사항 검토 필요
- 성능과 확장성
- 리액티브 프로그래밍 추상체를 이용하여 관리 가능한 코드 작성
- 부분 실패 처리
- 어플리케이션 아키텍처에서 선량한 시민 되기 (선량한 시민 : 다른 사람에게 부정적인 영향을 끼치지 않고 자신이 맡은 바 임무를 충실히 수행하는 시민)

> 성능과 확장성
- API 게이트웨이에 동기 I/O를 사용할 것인지, 비동기 I/O를 사용할 것인지를 선택하는 문제는 성능 및 확장성에 큰 영향을 미침
- 동기 I/O 모델
    - 각 네트워크 접속마다 쓰레드를 하나씩 배정하기 때문에 프로그래밍 모델이 간단하고 잘 작동
    - 하지만, 동기 I/O는 다소 무거운 OS 쓰레드를 사용하기 때문에 스레드 개수에 제약을 받으며, API 게이트웨이의 동시 접속 가능 개수가 제한적인 단점이 있음

- 비동기 I/O 모델 (논블록킹)
    - 단일 이벤트 루프 쓰레드가 I/O 요청을 각 이벤트 핸들러로 Dispatch (JVM 환경 : Netty, Vertext, Undertow 등, 비JVM 환경 : Node.js 가 유명)
    - 다중 쓰레드를 사용하는 오버헤드가 없기 때문에 확장성이 좋음
    - 하지만 비동기/콜백 기반의 프로그래밍 모델은 훨씬 복잡한 편이어서 코드 작성, 이해, 디버깅이 어려운 단점이 있음
    
- 논블록킹 I/O를 쓰는 것이 전체적으로 정말 더 나은 선택인지는 API 요청 처리 로직의 성격마다 다름
    - 넷플릭스 자사 엣지 서버 주울 (Zuul) 을 NIO로 재작성한 결과 
        - I/O 집약적 로직 (예 : 요청 라우팅) 수행 주울 클러스터 처리율 25% 증가 및 CPU 사용량 25% 감소
        - 반면, CPU 집약적 로직 (예 : 복호화, 압축)을 수행하는 주울 클러스터는 전혀 개선되지 않음  
        
> 리액티브 프로그래밍 추상체
- API 게이트웨이는 여러 백엔드 서비스 호출 결과를 조합
- 백엔드 서비스에 따라 클라이언트 요청 매개변수에 전적으로 의존하는 경우, 다른 서비스 요청의 결과에 의존하는 경우가 존재
    - 이러한 경우, API End-Point 핸들러 메서드가 디펜던시에 의해 결정된 순서대로 서비스를 호출하는 방식으로 해결
    - 하지만, 아래와 같이 순차 호출하면 결국 각 서비스의 응답 시간을 합한 만큼 기다려야 하므로 응답 시간을 줄이기 위해서는 가능한 한 동시에 서비스를 호출해야 함 
    - 따라서, API 조합 코드는 리액티브하게 선언형 스타일로 작성하는 것이 더 낫다
    > JVM 용 대표적 리액티브 추상체

    - 자바 8 - ComputableFutures
    - 리액터 프로젝트 - Mono
    - RxJava (Reactive Extensions for Java) 의 observable (넷플릭스에서 자사 API 게이트웨이 문제 해결을 위해 사용)
    - 스칼라 Future  

````java
// API End-Point 핸들러 메서드가 디펜던시에 의해 결정된 순서대로 서비스를 호출하는 방식
@RestContoller
public class OrderDetatilsController {
    
    @RequestMapping("/order/{orderId}")
    public OrderDetails getOrderDetails(@PathVariable String orderId) {
        OrderInfo orderInfo = orderService.findOrderById(orderId);
        TicketInfo ticketInfo = kitchenService.findTicketByOrderId(orderId);
        DeliveryInfo deliveryInfo = deliveryService.findDeliveryByOrderId(orderId);
        BillInfo billInfo = accountingService.findBillByOrderId(orderId);
        
        OrderDetails orderDetails = OrderDetails.makeOrderDetails(orderInfo, ticketInfo, deliveryInfo, billInfo);
        
        return orderDetails;        
    }
}
````

> 부분 실패 처리
- API 게이트웨이는 확장도 가능해야 하지만, 안정적으로 동작하는 것도 중요 (부하 분산기 뒷편에 여러 게이트웨이 인스턴스를 두고 가동)
    - 특정 인스턴스가 실패하면 부하 분산기가 알아서 요청을 다른 인스턴스에 라우팅
- 실패한 요청과 지연 시간이 너무 긴 요청을 적절히 잘 처리하는 것 또한 중요
    - 회로 차단기 (Circuit breaker) 패턴 적용
    
> 아키텍처의 선량한 시민 되기
- 서비스 디스커버리 패턴을 이용하면 API 게이트웨이 같은 서비스 클라이언트가 자신이 호출할 서비스 인스턴스의 네트워크 위치 파악 가능
- 관측성 패턴을 활용하면 개발자가 어플리케이션 동작 상태를 모니터링하고 문제를 진단하는 데 도움
    - 마이크로서비스 아키텍처는 요청 결과가 클라이언트에 반환되기까지 어떤 서비스를 어떻게 오갈지 알 수 없기 때문에 로그 파일 하나만으로는 원인을 파악하기 힘들고 복잡
    - 따라서 아래와 같은 패턴이 필요
        1. 헬스 체크 : 서비스 헬스를 반환하는 End-Point 표출
        2. 로그 수집 : 서비스 내역을 기록하고, 중앙 로깅 서버에 로그를 출력하여 검색/경고 기능 제공
        3. 분산 추적 : 각 외부 요청마다 ID를 부여하여 서비스를 통과하는 과정 추적
        4. 예외 추적 : 예외 발생 시 예외 추적 서비스에 보고 
        5. 어플리케이션 지표 : 카운터, 게이지 등의 지표를 측정하여 서버에 표출
        6. 감사 로깅 : 사용자가 한 일 기록
        
## API 게이트웨이 구현
- API 게이트웨이 역할
    > 요청 라우팅
    - 요청을 HTTP 메서드, 경로에 따라 서비스로 라우팅
    - API 게이트웨이는 HTTP 요청 메서드를 이용하여 적절한 CQRS 쿼리 서비스로 라우팅 (커맨드, 쿼리 분리) 
    > API 조합
    - REST End-Point 구현 및 요청 핸들러는 여러 서비스를 호출한 결과를 조합
    > 엣지 기능
    - 대표적 엣지 기능 인증
    > 프로토콜 변환
    - 서비스가 사용하는 클라이언트 친화적 프로토콜과 비친화적 프로토콜 상호 변환
    
- API 게이트웨이 구현 방법 2가지
    > 기성 API 게이트웨이 제품/서비스 활용
    - 개발 공수는 많이 안 들지만 유연성은 제일 떨어짐 (API 조합 지원 X)
    
    > API 게이트웨이 프레임워크 / 웹 프레임워크 기반으로 API 게이트웨이 직접 개발 
    - 가장 유연한 접근 방식이지만, 많은 개발 공수 필요
    
### 기성 API 게이트웨이 제품/서비스 활용
> AWS API 게이트웨이
- 아마존 웹 서비스가 제공하는 AWS API 게이트웨이는 API를 개발/관리하는 서비스
- 각각의 메서드, 리소스를 백엔드 서비스 (AWS 람다 함수, 어플리케이션에 정의된 HTTP 서비스, AWS 서비스 등)로 라우팅할 수 있게 구성해줌
- 필요 시 템플릿 기반으로 요청/응답을 변환하도록 구성 가능 
- 요청 인증 기능 내장
- API 조합 미지원 (직접 백엔드 서비스에 조합 로직 구현 필요)

> AWS 어플리케이션 부하 분산기
- AWS ALB (Application Load Balancer) 는 HTTP, HTTPS, 웹 소켓, HTTP/2용 부하 분산기
- AWS EC2 인스턴스에 가동 중인 백엔드 서비스로 요청 라우팅
- HTTP 메서드 기반의 라우팅, API 조합, 인증 미지원

> 다른 API 게이트웨이 제품
- 콩 (Kong) : Nginx HTTP 서버 기반
- 트래픽 (Traefix) : Go 언어 기반
- 두 제품 모두 HTTP 메서드, 헤더, 경로를 이용하여 백엔드 서비스를 선택하는 유연한 라우팅 규칙 구성 가능
- API 조합 미지원

### API 게이트웨이 자체 개발
- API 게이트웨이는 요청을 다른 서비스로 위임하는 웹 어플리케이션
- 아래 2가지 이슈는 신중히 검토 필요
    1. 코딩 복잡도를 최소화할 수 있는 라우팅 규칙 정의 메커니즘 구현
    2. HTTP 헤더 처리 등 HTTP 프록시 로직 구현 
    
> 넷플릭스 주울
- 넷플릭스 주울은 라우팅, 사용량 제한, 인증 같은 엣지 기능이 탑재된 프레임워크
    - 개념 자체는 자사용 가능 요청 인터셉터, 서블릿 필터, Node.js 익스프레스 미들웨어와 비슷
- HTTP 요청을 변환하는 필터 체인을 통해 요청 처리
- 백엔드 서비스 호출 후 클라이언트에 반환 직전 응답 가공
- 하지만, 경로 기반의 라우팅만 지원
    - GET : /orders 를 서비스 A로, POST : /orders 를 서비스 B로 라우팅 불가
    
> 스프링 클라우드 게이트웨이
- 스프링 클라우드 게이트웨이는 Spring 5, Spring Boot 2, Spring WebFlux 등의 프레임워크를 토대로 한 API 게이트웨이 프레임워크
- 요청 라우팅 처리 
- 인증 등의 엣지 기능 처리
- API 를 조합하는 요청 핸들러 역할

> 스프링 클라우드 게이트웨이