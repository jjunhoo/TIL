### 4.1 마이크로서비스 아키텍처에서의 트랜잭션 관리

#### 4-1-1. 분산 트랜잭션의 필요성

createOrder() 는 주문 가능한 소비자인지를 확인, 주문 내역 확인, 소비자 신용카드 승인, DB에 주문을 생성하는 작업을 한다.
모놀리식 어플리케이션에서는 주문 검증에 필요한 데이터를 그냥 가져와서 사용하거나 Spring Framework 를 사용할 경우, 
createOrder() 앞에 @Transactional 어노테이션을 붙이면 ACID 트랜잭션이 자동으로 걸려 데이터의 일관성이 보장된다.

하지만, 마이크로서비스에서 createOrder() 의 경우, 소비자 서비스, 주문 서비스, 주방 서비스, 회계 서비스 등 여러 서비스에 
있는 데이터에 접근해야하며, 서비스마다 DB가 따로 있기 때문에 여러 DB에 걸쳐 데이터 일관성을 유지할 수 있는 수단을 강구해야한다.

#### 4-1-2 분산 트랜잭션의 문제점

NoSQL (MongoDB, Cassandra DB) DB 와 현대 메시지 브로커 (RabbitMQ, Kafka) 는 분산 트랙잭션을 지원하지 않으므로
분산 트랜잭션이 필수라면 최근 기술은 상당수 포기할 수밖에 없다. 

또한 동기 IPC (Inter-Process Communication) 형태라서 가용성이 떨어지는 문제점도 있다. 
분산 트랜잭션은 참여한 서비스가 모두 가동 중이어야 커밋할 수 있다.

따라서 마이크로서비스 아키텍처에서 데이터 일관성을 유지하려면, 느슨하게 결합된 비동기 서비스 개념을 토대로 뭔가 다른 메커니즘이 절실한데, 
이것이 바로 SAGA 이다.

#### 4-1-3 데이터 일관성 유지 : SAGA 패턴

> SAGA 는 마이크로서비스 아키텍처에서 분산 트랜잭션 없이 데이터 일관성을 유지하는 메커니즘이다.   
비동기 메시징을 이용하여 편성한 일련의 로컬 트랜잭션으로 서비스 간 데이터 일관성은 SAGA 로 유지한다.

시스템 작업은 SAGA 의 첫 번째 단계를 시작한다. 어느 로컬 트랜잭션이 완료되면 이어서 그다음 로컬 트랜잭션이 실행된다.

SAGA 와 ACID 트랜잭션은 2가지 중요한 차이점이 있다.
첫째, ACID 트랜잭션에 있는 격리성이 SAGA 에는 없다.
둘째, SAGA 는 로컬 트랜잭션마다 변경분을 COMMIT 하므로 보상 트랜잭션을 걸어 ROLLBACK 해야한다.

> 예제 : 주문 생성 사가

1. 주문 서비스 : 주문을 APPROVAL_PENDING (승인 대기) 상태로 생성한다. 
2. 소비자 서비스 : 주문 가능한 소비자인지 확인한다.
3. 주방 서비스 : 주문 내역을 확인하고 티켓을 CREATE_PENDING (생성 대기) 상태로 생성한다.
4. 회계 서비스 : 소비자 신용카드를 승인한다.
5. 주방 서비스 : 티켓 상태를 AWAITING_ACCEPTANCE (대기 수락) 로 변경한다.
6. 주문 서비스 : 주문 상태를 APPROVED (승인) 로 변경한다. 

서비스는 로컬 트랜잭션이 완료되면, 메시지를 발행하여 다음 SAGA 단계를 트리거한다.
메시지를 통해 SAGA 참여자를 느슨하게 결합하고, SAGA 가 반드시 완료되도록 보장하는 것이다.
메시지 수신자가 일시 불능 상태라면, 메시지 브로커는 다시 메시지를 전달할 수 있을 때까지 메시지를 버퍼링한다.

> SAGA 는 '보상 트랜잭션'으로 변경분을 ROLLBACK 한다.
SAGA 는 단계마다 로컬 DB 에 변경분을 COMMIT 하므로 자동 ROLLBACK 은 불가능하다.
가령, 주문 생성 SAGA 4번째 단계에서 신용카드 승인이 실패하면, 1 ~ 3번째 단계에서 적용된 변경분을 명시적으로 UNDO 해야한다.
즉, 보상 트랜잭션을 미리 작성해야 한다.
SAGA 는 트랜잭션이 진행하는 반대 방향으로 보상 트랜잭션을 실행한다.

> 소비자 신용카드 승인 실패 시 보상 트랜잭션 작동 순서
1. 주문 서비스 : 주문을 APPROVAL_PENDING 상태로 생성한다.
2. 소비자 서비스 : 주문 가능한 소비자인지 확인한다.
3. 주방 서비스 : 주문 내역을 확인하고 티켓을 CREATE_PENDING 상태로 생성한다.
4. 회계 서비스 : 소비자 신용카드 승인 요청이 거부된다.
5. 주방 서비스 : 티켓 상태를 CREATE_REJECTED 로 변경한다.
6. 주문 서비스 : 주문 상태를 REJECTED 로 변경한다.

5 ~ 6번째 단계는 주방 서비스, 주문 서비스가 수행한 업데이트를 UNDO 하는 보상 트랜잭션이다.

### 4-2. SAGA 편성

SAGA 는 단계를 편성하는 로직으로 구성된다. 시스템 커맨드가 SAGA 를 시작할 때 이 편성 로직은 첫 번째 SAGA 참여자를 정하여
로컬 트랜잭션 실행을 지시하고, 트랜잭션이 완료되면 그다음 SAGA 참여자를 호출하는 과정이 모든 단계가 실행될 때까지 반복된다.
도중에 하나라도 로컬 트랜잭션이 실패하면 SAGA 는 보상 트랜잭션을 역순으로 실행한다. 

SAGA 편성 로직은 2가지 종류가 있다.

1. 코레오그래피 (Choreography)
- 의사 결정과 순서화를 SAGA 참여자에게 맡긴다. SAGA 참여자는 주로 이벤트 교환 방식으로 통신한다.

2. 오케스트레이션 (Orchestration)
- SAGA 편성 로직을 SAGA 오케스트레이터에 중앙화한다. SAGA 오케스트레이터는 SAGA 참여자에게 커맨드 메시지를 보내 수행할 작업을 지시한다.

#### 4-2-1. 코레오그래피 SAGA

코레오그래피 방식은 SAGA 참여자가 할 일을 알려주는 SAGA 오케스트레이터가 없고, SAGA 참여자가 서로 이벤트를 구독해서 그에 따라 반응한다.

> 주문 생성 SAGA 구현 : 코레오그래피

1. 주문 서비스 : 주문을 APPROVAL_PENDING 상태로 생성 -> 주문 생성 이벤트 발행
2. 소비자 서비스 : 주문 생성 이벤트 수신 -> 소비자가 주문을 할 수 있는지 확인 -> 소비자 확인 이벤트 발행
3. 주방 서비스 : 주문 생성 이벤트 수신 -> 주문 내역 확인 -> 티켓을 CREATE_PENDING 상태로 생성 -> 티켓 생성됨 이벤트 발행
4. 회계 서비스 : 주문 생성 이벤트 수신 -> 신용카드 승인을 PENDING 상태로 생성
5. 회계 서비스 : 티켓 생성 및 소비자 확인 이벤트 수신 -> 소비자 신용카드 과금 -> 신용카드 승인됨 이벤트 발행
6. 주방 서비스 : 신용카드 승인 이벤트 수신 -> 티켓 상태를 AWAITING_ACCEPTANCE 로 변경
7. 주문 서비스 : 신용카드 승인됨 이벤트 수신 -> 주문 상태를 APPROVED 로 변경 -> 주문 승인됨 이벤트 발행

> 코레오그래피 - 회계 서비스에서 소비자 신용카드가 승인 거부된 경우
1. 주문 서비스 : 주문을 APPROVAL_PENDING 상태로 생성 -> 주문 생성 이벤트 발행
2. 소비자 서비스 : 주문 생성 이벤트 수신 -> 소비자가 주문을 할 수 있는지 확인 -> 소비자 확인 이벤트 발행
3. 주방 서비스 : 주문 생성 이벤트 수신 -> 주문 내역 확인 -> 티켓을 CREATE_PENDING 상태로 생성 -> 티켓 생성됨 이벤트 발행
4. 회계 서비스 : 주문 생성 이벤트 수신 -> 신용카드 승인을 PENDING 상태로 생성
* 5. 회계 서비스 : 티켓 생성 및 소비자 확인 이벤트 수신 -> 소비자 신용카드 과금 -> 신용카드 승인 실패 이벤트 발행
* 6. 주방 서비스 : 신용카드 승인 실패 이벤트 수신 -> 티켓 상태를 REJECTED 로 변경
* 7. 주문 서비스 : 신용카드 승인 실패 이벤트 수신 -> 주문 상태를 REJECTED 로 변경

> 코레오그래피 SAGA 장단점
- 장점
1. 단순함
- 비즈니스 객체를 생성, 수정, 삭제할 때 서비스가 이벤트를 발행한다.
2. 느슨한 결합
- 참여자는 이벤트를 구독할 뿐 서로를 직접 알지 못한다.

- 단점
1. 이해하기 어렵다
- 오케스트레이션 SAGA 와 달리, SAGA 를 어느 한곳에 정의한 것이 아니라서 여러 서비스에 구현 로직이 흩어져 있다.
따라서 어떤 SAGA 가 어떻게 작동되는지 개발자가 이해하기 어렵다.
2. 서비스 간 순환 의존성 
- 참여자가 서로 이벤트를 구독하는 특성상, 순환 의존성이 발행하기 쉽기 때문에 잠재적인 설계 취약점이 될 수 있다.
3. 단단히 결합될 위험성 
- SAGA 참여자는 각자 자신에게 영향을 미치는 이벤트를 모두 구독해야 한다.

> 간단한 SAGA 라면 코레오그래피 방식으로도 충분하지만, 복잡한 SAGA 는 오케스트레이션 방식이 적합하다!   
