## 프로덕션 레디 서비스 개발
> 서비스를 프로덕션에 배포할 수 있게 준비하려면 3가지 핵심 품질 속성이 보장되어야 한다.
- 보안
- 구성성
- 관측성

## 보안 서비스 개발
어플리케이션 개발자는 주로 다음 4가지 보안 요소를 구현
> 인증
- 어플리케이션에 접근하는 어플리케이션이나 사람의 신원 확인 (ID/PW)
> 인가
- 주체가 어떤 데이터에 어떤 작업을 요청하여 수행할 수 있는 권한이 있는지 확인
- 역할 기반 (Role-Based) 보안 및 ACL (Access Control List) 을 함께 사용
> 감사
- 보안 이슈 탐지 
> 보안 IPC
- 모든 서비스를 드나드는 통신이 '전송 계층 보안' 을 경유하는 것이 이상적

### 기존 모놀리식 어플리케이션의 보안

![캡처](https://velog.velcdn.com/images/litien/post/178509d6-6db2-45e1-97db-11b96e59b7e2/image.png)

![캡처](https://velog.velcdn.com/images%2Flitien%2Fpost%2Fae30f5a8-0f1b-475c-8c12-37a2b923b827%2Fimage.png)

- 보안 아키텍처의 핵심은 세션과 보안 컨텍스트
- 보안 컨텍스트 
    - 현재 요청을 보낸 사용자의 정보를 담는 용도로 사용
    - 스프링 시큐리티에서는 보안 컨텍스트를 정적 스레드 로컬 변수에 저장 (* 오직 하나의 쓰레드만 읽고 쓸 수 있는 변수 생성)
    - 따라서, 모든 요청 핸들러가 보안 컨텍스트에 접근 가능
- Role
    - 소비자(CUSTOMER), 음식점(RESTAURANT), 배달원(COURIER), 관리자(ADMIN)
    
> 단점
- 특정 세션의 요청을 모두 동일한 Application 인스턴스로 라우팅하는 것
    - 부하 분산이 어려움 (Application 인스턴스를 닫기 전에 모든 세션이 만료되기를 기다리는 세션 배수 메커니즘 구현 필요)
    
### 마이크로서비스 아키텍처에서의 보안 구현
- MSA 는 모든 외부 요청을 API 게이트웨이와 하나 이상의 서비스가 처리하는 분산 시스템
- 따라서, 보안을 구현하기 위해서는 먼저 사용자의 인증/인가 처리를 누가 담당할지부터 결정 필요
- 다음 2가지 보안 요소 고민 필요
    - 인-메모리 보안 컨텍스트
    - 중앙화 세션
        - 각각의 서비스들은 메모리(쓰레드 로컬)를 공유할 수 없음 
 
![캡처](https://velog.velcdn.com/images%2Flitien%2Fpost%2Fbda39b68-980c-4ee2-905c-1b284bc5c5d0%2Fimage.png)

> API 게이트웨이에서 인증 처리
- 요청을 서비스에 보내기 전에 API 게이트웨이가 요청을 인증 
    - 인증 로직을 중앙화하면 관리 포인트가 한곳으로 집중
    - 다양한 인증 메커니즘을 API 게이트웨이에 캡슐화 가능 (인증 관련 코드를 서비스에서 분리)

- API 기반 클라이언트    
    1. 클라이언트는 자격증명이 포함된 요청을 전송
    2. API 게이트웨이는 자격증명을 인증하고, 보안 토큰을 생성해서 서비스들에 전달
- 로그인 기반 클라이언트
    1. 클라이언트는 자격증명이 포함된 로그인 요청
    2. API 게이트웨이는 보안 토큰 반환
    3. 클라이언트는 작업을 호출하는 요청에 보안 토큰을 넣어 요청 
    4. API 게이트웨이는 보안 토큰을 검증하고 해당 서비스로 포워딩
    
> 인가 처리
- 인가 메커니즘은 API 게이트웨이에 구현하게 되면 API 게이트웨이와 서비스가 단단하게 결합
    - 추후 변경 필요 시 서로 맞물릴 수 있음
- 또한 API 게이트웨이는 역할 기반의 URL 경로 접근만 구현 가능
    - API 게이트웨이가 서비스 도메인 로직의 세부 내용까지 알고 있는 것은 무리
- 따라서, 인가 로직은 서비스에 구현하는 것이 바람직

> JWT로 사용자 신원/역할 전달

- 어떤 종류의 토큰에 사용자 정보를 담아 서비스에 전달할지 결정 필요
- 토큰 종류

1. 난독화 토큰
    - 보통 UUID (Universally Unique Identifier - 범용 고유 식별자) 사용
    - 하지만, 성능 및 가용성이 떨어지고, 지연 시간이 긴 단점 존재 
        - 토큰 수신자가 유효성 검증 및 보안 서비스를 동기 RPC 호출하여 사용자 정보 조회 필요

2. 투명 토큰 
    - 보안 서비스 호출이 필요 없음
    - 사용자 정보, 만료일자 등의 메타데이터가 포함된 JSON 객체를 페이로드에 저장
    - JWT 생성자 (API 게이트웨이)와 JWT 수신자 (서비스)만 알 수 있는 시크릿으로 서명
    - 하지만, JWT는 토큰 자체가 포함되어 있기 때문에 취소 불가능한 문제점 존재
        - JWT가 최대한 가까운 미래에 만료되도록 설정 후 재발행하는 메커니즘으로 해결 가능
        
> OAuth 2.0 응용

OAuth 2.0 핵심 개념
- 인증 서버 
    - 사용자 인증, 엑세스/리프레시 토큰 획득 API 제공
- 엑세스 토큰
    - 리소스 서버 접근을 허가하는 토큰
    - 엑세스 토큰 만료 시 리프레시 토큰을 이용하여 엑세스 토큰 재발급
- 리프레시 토큰
    - 클라이언트가 새 엑세스 토큰을 얻기 위해 필요한 토큰
- 리소스 서버
    - 엑세스 토큰으로 접근을 허가하는 서비스 (MSA에서는 서버가 곧 리소스)
- 클라이언트  
    - 리소스 서버에 접근하려는 클라이언트 (MSA에서는 API 게이트웨이가 곧 클라이언트)
    
API 기반 클라이언트 인증 방법
1. 클라이언트는 기본 인증을 이용하여 자격증명(authorization)과 함께 요청 (예 : Authrization : Basic)
2. API 게이트웨이는 OAuth 2.0 인증 서버에 패스워드 승인 요청
3. 인증 서버는 API 클라이언트의 자격증명을 검증하고 엑세스/리프레시 토큰 반환
4. API 게이트웨이는 서비스에 요청을 할 때마다 발급받은 엑세스 토큰을 넣어 보내고, 서비스는 엑세스 토큰을 이용하여 요청을 인증

로그인 기반 클라이언트 인증 방법
1. 로그인 기반의 클라이언트가 자격증명(id/pw)을 API 게이트웨이에 POST 
2. API 게이트웨이의 로그인 핸들러는 OAuth 2.0 인증 서버에 패스워드 승인 요청
3. 인증 서버는 클라이언트의 자격증명을 검증 후 엑세스/리프레시 토큰 반환
4. API 게이트웨이는 인증 서버에서 받은 두 토큰을 클라이언트에 반환 
5. 클라이언트는 엑세스/리프레시 토큰을 API 게이트웨이에 요청 마다 실어 보냄
6. API 게이트웨이의 세션 인증 인터셉터는 엑세스 토큰을 검증 후 서비스에 토큰을 넣어 보냄