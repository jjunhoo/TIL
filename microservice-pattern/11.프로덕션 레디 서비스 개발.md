## 프로덕션 레디 서비스 개발
> 서비스를 프로덕션에 배포할 수 있게 준비하려면 3가지 핵심 품질 속성이 보장되어야 한다.
- 보안
- 구성성
- 관측성

## 보안 서비스 개발
어플리케이션 개발자는 주로 다음 4가지 보안 요소를 구현
> 인증
- 어플리케이션에 접근하는 어플리케이션이나 사람의 신원 확인 (ID/PW)
> 인가
- 주체가 어떤 데이터에 어떤 작업을 요청하여 수행할 수 있는 권한이 있는지 확인
- 역할 기반 (Role-Based) 보안 및 ACL (Access Control List) 을 함께 사용
> 감사
- 보안 이슈 탐지 
> 보안 IPC
- 모든 서비스를 드나드는 통신이 '전송 계층 보안' 을 경유하는 것이 이상적

### 기존 모놀리식 어플리케이션의 보안

![캡처](https://velog.velcdn.com/images/litien/post/178509d6-6db2-45e1-97db-11b96e59b7e2/image.png)

![캡처](https://velog.velcdn.com/images%2Flitien%2Fpost%2Fae30f5a8-0f1b-475c-8c12-37a2b923b827%2Fimage.png)

- 보안 아키텍처의 핵심은 세션과 보안 컨텍스트
- 보안 컨텍스트 
    - 현재 요청을 보낸 사용자의 정보를 담는 용도로 사용
    - 스프링 시큐리티에서는 보안 컨텍스트를 정적 스레드 로컬 변수에 저장 (* 오직 하나의 쓰레드만 읽고 쓸 수 있는 변수 생성)
    - 따라서, 모든 요청 핸들러가 보안 컨텍스트에 접근 가능
- Role
    - 소비자(CUSTOMER), 음식점(RESTAURANT), 배달원(COURIER), 관리자(ADMIN)
    
> 단점
- 특정 세션의 요청을 모두 동일한 Application 인스턴스로 라우팅하는 것
    - 부하 분산이 어려움 (Application 인스턴스를 닫기 전에 모든 세션이 만료되기를 기다리는 세션 배수 메커니즘 구현 필요)
    
### 마이크로서비스 아키텍처에서의 보안 구현
- MSA 는 모든 외부 요청을 API 게이트웨이와 하나 이상의 서비스가 처리하는 분산 시스템
- 따라서, 보안을 구현하기 위해서는 먼저 사용자의 인증/인가 처리를 누가 담당할지부터 결정 필요
- 다음 2가지 보안 요소 고민 필요
    - 인-메모리 보안 컨텍스트
    - 중앙화 세션
        - 각각의 서비스들은 메모리(쓰레드 로컬)를 공유할 수 없음 
 
![캡처](https://velog.velcdn.com/images%2Flitien%2Fpost%2Fbda39b68-980c-4ee2-905c-1b284bc5c5d0%2Fimage.png)

> API 게이트웨이에서 인증 처리
- 요청을 서비스에 보내기 전에 API 게이트웨이가 요청을 인증 
    - 인증 로직을 중앙화하면 관리 포인트가 한곳으로 집중
    - 다양한 인증 메커니즘을 API 게이트웨이에 캡슐화 가능 (인증 관련 코드를 서비스에서 분리)

- API 기반 클라이언트    
    1. 클라이언트는 자격증명이 포함된 요청을 전송
    2. API 게이트웨이는 자격증명을 인증하고, 보안 토큰을 생성해서 서비스들에 전달
- 로그인 기반 클라이언트
    1. 클라이언트는 자격증명이 포함된 로그인 요청
    2. API 게이트웨이는 보안 토큰 반환
    3. 클라이언트는 작업을 호출하는 요청에 보안 토큰을 넣어 요청 
    4. API 게이트웨이는 보안 토큰을 검증하고 해당 서비스로 포워딩
    
> 인가 처리
- 인가 메커니즘은 API 게이트웨이에 구현하게 되면 API 게이트웨이와 서비스가 단단하게 결합
    - 추후 변경 필요 시 서로 맞물릴 수 있음
- 또한 API 게이트웨이는 역할 기반의 URL 경로 접근만 구현 가능
    - API 게이트웨이가 서비스 도메인 로직의 세부 내용까지 알고 있는 것은 무리
- 따라서, 인가 로직은 서비스에 구현하는 것이 바람직

> JWT로 사용자 신원/역할 전달

- 어떤 종류의 토큰에 사용자 정보를 담아 서비스에 전달할지 결정 필요
- 토큰 종류

1. 난독화 토큰
    - 보통 UUID (Universally Unique Identifier - 범용 고유 식별자) 사용
    - 하지만, 성능 및 가용성이 떨어지고, 지연 시간이 긴 단점 존재 
        - 토큰 수신자가 유효성 검증 및 보안 서비스를 동기 RPC 호출하여 사용자 정보 조회 필요

2. 투명 토큰 
    - 보안 서비스 호출이 필요 없음
    - 사용자 정보, 만료일자 등의 메타데이터가 포함된 JSON 객체를 페이로드에 저장
    - JWT 생성자 (API 게이트웨이)와 JWT 수신자 (서비스)만 알 수 있는 시크릿으로 서명
    - 하지만, JWT는 토큰 자체가 포함되어 있기 때문에 취소 불가능한 문제점 존재
        - JWT가 최대한 가까운 미래에 만료되도록 설정 후 재발행하는 메커니즘으로 해결 가능
        
> OAuth 2.0 응용

OAuth 2.0 핵심 개념
- 인증 서버 
    - 사용자 인증, 엑세스/리프레시 토큰 획득 API 제공
- 엑세스 토큰
    - 리소스 서버 접근을 허가하는 토큰
    - 엑세스 토큰 만료 시 리프레시 토큰을 이용하여 엑세스 토큰 재발급
- 리프레시 토큰
    - 클라이언트가 새 엑세스 토큰을 얻기 위해 필요한 토큰
- 리소스 서버
    - 엑세스 토큰으로 접근을 허가하는 서비스 (MSA에서는 서버가 곧 리소스)
- 클라이언트  
    - 리소스 서버에 접근하려는 클라이언트 (MSA에서는 API 게이트웨이가 곧 클라이언트)
    
API 기반 클라이언트 인증 방법
1. 클라이언트는 기본 인증을 이용하여 자격증명(authorization)과 함께 요청 (예 : Authrization : Basic)
2. API 게이트웨이는 OAuth 2.0 인증 서버에 패스워드 승인 요청
3. 인증 서버는 API 클라이언트의 자격증명을 검증하고 엑세스/리프레시 토큰 반환
4. API 게이트웨이는 서비스에 요청을 할 때마다 발급받은 엑세스 토큰을 넣어 보내고, 서비스는 엑세스 토큰을 이용하여 요청을 인증

로그인 기반 클라이언트 인증 방법
1. 로그인 기반의 클라이언트가 자격증명(id/pw)을 API 게이트웨이에 POST 
2. API 게이트웨이의 로그인 핸들러는 OAuth 2.0 인증 서버에 패스워드 승인 요청
3. 인증 서버는 클라이언트의 자격증명을 검증 후 엑세스/리프레시 토큰 반환
4. API 게이트웨이는 인증 서버에서 받은 두 토큰을 클라이언트에 반환 
5. 클라이언트는 엑세스/리프레시 토큰을 API 게이트웨이에 요청 마다 실어 보냄
6. API 게이트웨이의 세션 인증 인터셉터는 엑세스 토큰을 검증 후 서비스에 토큰을 넣어 보냄

## 구성 가능한 서비스 설계
- 서비스 실행에 필요한 구성 프로퍼티(DB 도메인, 자격증명 등)는 실행 환경마다 다르므로 배포 서비스에 하드 코딩하는 것은 비효율
- Spring Framework 의 프로파일 장치로 런타임에 프로퍼티 세트를 선택하는 구조는 보안에 취약하며 배포에 한계
- 따라서, 외부화 구성 패턴에 따라 런타임에 적합한 구성 프로퍼티를 서비스에 제공하는 방법 권장
    - Push 모델
        - OS 환경 변수, 구성 파일 등을 통해 배포 인프라에서 서비스로 프로퍼티 값을 전달하는 방식
    - Pull 모델
        - 서비스 인스턴스가 구성 서버에 접속해서 프로퍼티 값을 읽어 오는 방식  
        
### 푸시 기반의 외부화 구성

- 푸시 모델에서 배포 환경은 서비스 인스턴스가 생성될 때 프로퍼티 값 제공
````java
public class OrderHistoryDynamoDBConfiguration {
    @Value("${aws.region}")
    private String awsRegion;
}
````
- 푸시 모델은 현재도 많이 사용되는 기술이지만, 실행중인 서비스를 재구성하기는 어려운 한계가 있음
- 또한 구성 프로퍼티 값이 여러 서비스에 흩어지는 문제
- 따라서 풀 모델 검토 필요

### 풀 기반의 외부화 구성

- 풀 모델은 서비스 인스턴스 시동 시 자신이 필요한 값을 구성 전용 서버에 접속하여 읽는 방식
- 구성 서버 
    - 버전 관리 시스템 (예 :Git, SVN)
    - SQL/NoSQL DB 
    - 전용 구성 서버 (예 : Spring Cloud Config Server)
![캡처](https://velog.velcdn.com/images%2Flitien%2Fpost%2Feb6d4e71-ab6f-4a75-a242-52bbdf1a73f1%2Fimage.png)
- 구성 서버 운영 시 장점
    > 중앙화 구성 
    - 운영 포인트 집중화
    > 민감한 데이터의 투명한 복호화
    - 프로퍼티를 자동 복호화해서 서비스에 전달
    > 동적 재구성
    - 수정된 프로퍼티 값을 감지해서 자동 재구성 가능

## 관측 가능한 서비스 설계
서비스 인스턴스의 동작과 헬스가 표출되면 관리가 용이하고, 보다 편리한 트러블슈팅이 가능
> 헬스 체크 API 
- 서비스 헬스를 반환하는 끝점 표출
> 로그 수집
- 서비스 활동을 로깅하며 검색/경고 기능이 구현된 중앙 로그 서버에 로그 출력
> 분산 추적
- 각 외부 요청에 ID(traceId)를 하나씩 붙여 서비스 사이를 드나드는 과정 추적
> 예외 추적
- 예외 중복 제거, 개발자 알림, 예외별 해결 상황 추적 등을 수행하는 예외 추적 서비스에 예외 보고
> 어플리케이션 지표
- 서비스는 카운터, 게이지 등 지표를 유지하고, 수집한 데이터를 지표 서버에 표출
> 감사 로깅 
- 사용자 액션 로깅

![캡처](https://velog.velcdn.com/images%2Flitien%2Fpost%2F25662f7f-36dd-435f-a095-3f7ca0afa2f5%2Fimage.png)

### 헬스 체크 API 패턴
- 배포 인프라가 호출 가능한 헬스 체크 끝점을 서비스에 구현하는 것이 바람직
- 서비스 상태를 반환하는 'GET /health' 등의 헬스 체크 API 끝점 표출
    - 예 : Spring Boot Actuator 
- 헬스 체크 요청 핸들러
    - DB에 테스트 쿼리를 전송 
        - 정상 : 200, 문제 발생 시 : 500 리턴

### 로그 수집 패턴
- 어플리케이션 문제 확인을 위해서는 로그 파일 분석이 반드시 필요
- 전체 서비스 로그를 중앙 DB에 수집하여 검색/알림 기능 제공
> 서비스 로그 생성
    - 로깅 라이브러리 
        - Logback, Log4j, Slf4J 등
    - 로깅 장소 
        - 과거 : 파일 시스템 경로에 로그 파일 저장
        - 현재 : AWS 람다에서는 stdout 에 로깅

> 로그 수집 인프라
    - ELK 
        - Elasticsearch : 로깅 서버 (텍스트 검색 지향 NoSQL)
        - Logstash : 서비스 로그를 수집하여 ES 에 출력하는 로그 파이프라인
            - 이외 오픈 소스 로그 파이프라인 : Fluentd, Apache Flume, AWS CloudWatch Logs 등
        - Kibana : ES 용 시각화 툴  

![캡처](https://velog.velcdn.com/images%2Flitien%2Fpost%2Ff5aac251-f57d-43e5-855f-33c81c92b80e%2Fimage.png)
        
### 분산 추적 패턴
- 외부 요청마다 유일한 ID를 하나씩 부여해서 한 서비스에서 다음 서비스로 흘러가는 과정을 기록
- 시각화/분석 기능을 제공하는 중앙화 서버에 저장
- 서비스 호출 트리 정보 기록 (시작 시작, 종료 시간)
- 분산 추적은 '인스트루멘테이션 라이브러리'와 '분산 추적 서버'로 구성
    - 인스트루멘테이션 라이브러리 
        - 추적 정보(트레이스 ID, 부모 스팬 ID) 를 아웃바운드 요청에 추가 및 분산 추적 서버에 트레이스를 보고
    - 분산 추적 서버
        - 트레이스 저장 및 UI 시각화
- 인스트루멘테이션 로직은 Interceptor나 AOP 를 이용하는 것이 깔끔

### 어플리케이션 지표 패턴
- 서비스는 수집, 시각화, 알림 기능을 제공하는 중앙 서버로 지표를 보고 
- 서비스 개발자가 해야할 것 
    - 서비스가 자신의 동작에 관한 지표를 수집하도록 구현
    - 지표를 JVM 및 어플리케이션 프레임워크 수준에서 수집한 지표와 함께 지표 서버에 표출
        - 서비스는 수집한 지표를 Push 또는 Pull 방식으로 메트릭스 서버에 전달
        
### 예외 추적 패턴
- 서비스는 중복된 예외를 제거하고, 알림을 생하고, 예외 해결 과정을 관리하는 중앙 서비스에 예외를 보고

### 감사 로깅 패턴
- 고객 지원, 컴플라이언스 준수, 수상한 동작 감지를 위해 사용자 액션을 DB에 저장
- 구현 방법
    1. 감사 로깅 코드를 비즈니스 로직에 추가
    2. AOP 활용
    3. 이벤트 소싱 이용

## 서비스 개발 : 마이크로서비스 섀시 패턴
- 마이크로서비스 섀시는 횡단 관심사 처리에 특화된 프레임워크 
    - 예외 추적, 로깅, 헬스 체크, 외부화 구성, 분산 추적, 어플리케이션 지표, 서비스 디스커버리, 회로 차단기 등의 횡단 관심사를 처리하는 프레임워크를 기반으로 서비스를 구축
 
![캡처](https://velog.velcdn.com/images%2Flitien%2Fpost%2F954761eb-7047-4290-8bfa-3ec4cc3132dc%2Fimage.png)

- 마이크로서비스 섀시는 언어(Java, Node.js 등) 마다 각각 하나씩 필요하는 단점 존재 
    - 따라서, 공통 기능 일부를 서비스 외부에 위치한 서비스 메시에 구현
    - 한 서비스와 다른 서비스, 그리고 외부간의 소통을 조정하는 인프라
        - 서비스를 드나드는 트래픽은 모두 회로 차단기, 분산 추적, 서비스 디스커버리, 부하 분산, 룰 기반 트래픽 라우팅 등 다양한 관심사가 구현된 서비스 메시를 통과 
- 서비스 메시의 종류 
    - Istio (이스티오)
    - Linkerd (링커드)
    - Conduit (콘듀이트)